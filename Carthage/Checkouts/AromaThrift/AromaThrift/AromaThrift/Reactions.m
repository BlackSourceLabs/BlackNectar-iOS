/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"
#import "TAsyncTransport.h"
#import "TProtocolFactory.h"
#import "TBaseClient.h"

#import "Aroma.h"

#import "Reactions.h"

@implementation AromaReactions_MatcherAll

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherAll class]]) {
    return NO;
  }
  AromaReactions_MatcherAll *other = (AromaReactions_MatcherAll *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherAll"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherAll("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherTitleIs

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithExpectedTitle: (NSString *) expectedTitle
{
  self = [super init];
  __expectedTitle = [expectedTitle retain_stub];
  __expectedTitle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"expectedTitle"])
  {
    __expectedTitle = [[decoder decodeObjectForKey: @"expectedTitle"] retain_stub];
    __expectedTitle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__expectedTitle_isset)
  {
    [encoder encodeObject: __expectedTitle forKey: @"expectedTitle"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __expectedTitle_isset ? 2654435761 : 0;
  if (__expectedTitle_isset)
  {
    hash = (hash * 31) ^ [__expectedTitle hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherTitleIs class]]) {
    return NO;
  }
  AromaReactions_MatcherTitleIs *other = (AromaReactions_MatcherTitleIs *)anObject;
  if ((__expectedTitle_isset != other->__expectedTitle_isset) ||
      (__expectedTitle_isset && ((__expectedTitle || other->__expectedTitle) && ![__expectedTitle isEqual:other->__expectedTitle]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__expectedTitle release_stub];
  [super dealloc_stub];
}

- (NSString *) expectedTitle {
  return [[__expectedTitle retain_stub] autorelease_stub];
}

- (void) setExpectedTitle: (NSString *) expectedTitle {
  [expectedTitle retain_stub];
  [__expectedTitle release_stub];
  __expectedTitle = expectedTitle;
  __expectedTitle_isset = YES;
}

- (BOOL) expectedTitleIsSet {
  return __expectedTitle_isset;
}

- (void) unsetExpectedTitle {
  [__expectedTitle release_stub];
  __expectedTitle = nil;
  __expectedTitle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setExpectedTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherTitleIs"];
  if (__expectedTitle_isset) {
    if (__expectedTitle != nil) {
      [outProtocol writeFieldBeginWithName: @"expectedTitle" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __expectedTitle];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherTitleIs("];
  [ms appendString: @"expectedTitle:"];
  [ms appendFormat: @"\"%@\"", __expectedTitle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherTitleIsNot

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithTitle: (NSString *) title
{
  self = [super init];
  __title = [title retain_stub];
  __title_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain_stub];
    __title_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __title_isset ? 2654435761 : 0;
  if (__title_isset)
  {
    hash = (hash * 31) ^ [__title hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherTitleIsNot class]]) {
    return NO;
  }
  AromaReactions_MatcherTitleIsNot *other = (AromaReactions_MatcherTitleIsNot *)anObject;
  if ((__title_isset != other->__title_isset) ||
      (__title_isset && ((__title || other->__title) && ![__title isEqual:other->__title]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__title release_stub];
  [super dealloc_stub];
}

- (NSString *) title {
  return [[__title retain_stub] autorelease_stub];
}

- (void) setTitle: (NSString *) title {
  [title retain_stub];
  [__title release_stub];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release_stub];
  __title = nil;
  __title_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherTitleIsNot"];
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherTitleIsNot("];
  [ms appendString: @"title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherTitleContains

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSubstring: (NSString *) substring
{
  self = [super init];
  __substring = [substring retain_stub];
  __substring_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"substring"])
  {
    __substring = [[decoder decodeObjectForKey: @"substring"] retain_stub];
    __substring_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__substring_isset)
  {
    [encoder encodeObject: __substring forKey: @"substring"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __substring_isset ? 2654435761 : 0;
  if (__substring_isset)
  {
    hash = (hash * 31) ^ [__substring hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherTitleContains class]]) {
    return NO;
  }
  AromaReactions_MatcherTitleContains *other = (AromaReactions_MatcherTitleContains *)anObject;
  if ((__substring_isset != other->__substring_isset) ||
      (__substring_isset && ((__substring || other->__substring) && ![__substring isEqual:other->__substring]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__substring release_stub];
  [super dealloc_stub];
}

- (NSString *) substring {
  return [[__substring retain_stub] autorelease_stub];
}

- (void) setSubstring: (NSString *) substring {
  [substring retain_stub];
  [__substring release_stub];
  __substring = substring;
  __substring_isset = YES;
}

- (BOOL) substringIsSet {
  return __substring_isset;
}

- (void) unsetSubstring {
  [__substring release_stub];
  __substring = nil;
  __substring_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubstring: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherTitleContains"];
  if (__substring_isset) {
    if (__substring != nil) {
      [outProtocol writeFieldBeginWithName: @"substring" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __substring];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherTitleContains("];
  [ms appendString: @"substring:"];
  [ms appendFormat: @"\"%@\"", __substring];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherTitleDoesNotContain

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSubstring: (NSString *) substring
{
  self = [super init];
  __substring = [substring retain_stub];
  __substring_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"substring"])
  {
    __substring = [[decoder decodeObjectForKey: @"substring"] retain_stub];
    __substring_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__substring_isset)
  {
    [encoder encodeObject: __substring forKey: @"substring"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __substring_isset ? 2654435761 : 0;
  if (__substring_isset)
  {
    hash = (hash * 31) ^ [__substring hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherTitleDoesNotContain class]]) {
    return NO;
  }
  AromaReactions_MatcherTitleDoesNotContain *other = (AromaReactions_MatcherTitleDoesNotContain *)anObject;
  if ((__substring_isset != other->__substring_isset) ||
      (__substring_isset && ((__substring || other->__substring) && ![__substring isEqual:other->__substring]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__substring release_stub];
  [super dealloc_stub];
}

- (NSString *) substring {
  return [[__substring retain_stub] autorelease_stub];
}

- (void) setSubstring: (NSString *) substring {
  [substring retain_stub];
  [__substring release_stub];
  __substring = substring;
  __substring_isset = YES;
}

- (BOOL) substringIsSet {
  return __substring_isset;
}

- (void) unsetSubstring {
  [__substring release_stub];
  __substring = nil;
  __substring_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubstring: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherTitleDoesNotContain"];
  if (__substring_isset) {
    if (__substring != nil) {
      [outProtocol writeFieldBeginWithName: @"substring" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __substring];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherTitleDoesNotContain("];
  [ms appendString: @"substring:"];
  [ms appendFormat: @"\"%@\"", __substring];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherBodyIs

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithExpectedBody: (NSString *) expectedBody
{
  self = [super init];
  __expectedBody = [expectedBody retain_stub];
  __expectedBody_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"expectedBody"])
  {
    __expectedBody = [[decoder decodeObjectForKey: @"expectedBody"] retain_stub];
    __expectedBody_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__expectedBody_isset)
  {
    [encoder encodeObject: __expectedBody forKey: @"expectedBody"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __expectedBody_isset ? 2654435761 : 0;
  if (__expectedBody_isset)
  {
    hash = (hash * 31) ^ [__expectedBody hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherBodyIs class]]) {
    return NO;
  }
  AromaReactions_MatcherBodyIs *other = (AromaReactions_MatcherBodyIs *)anObject;
  if ((__expectedBody_isset != other->__expectedBody_isset) ||
      (__expectedBody_isset && ((__expectedBody || other->__expectedBody) && ![__expectedBody isEqual:other->__expectedBody]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__expectedBody release_stub];
  [super dealloc_stub];
}

- (NSString *) expectedBody {
  return [[__expectedBody retain_stub] autorelease_stub];
}

- (void) setExpectedBody: (NSString *) expectedBody {
  [expectedBody retain_stub];
  [__expectedBody release_stub];
  __expectedBody = expectedBody;
  __expectedBody_isset = YES;
}

- (BOOL) expectedBodyIsSet {
  return __expectedBody_isset;
}

- (void) unsetExpectedBody {
  [__expectedBody release_stub];
  __expectedBody = nil;
  __expectedBody_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setExpectedBody: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherBodyIs"];
  if (__expectedBody_isset) {
    if (__expectedBody != nil) {
      [outProtocol writeFieldBeginWithName: @"expectedBody" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __expectedBody];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherBodyIs("];
  [ms appendString: @"expectedBody:"];
  [ms appendFormat: @"\"%@\"", __expectedBody];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherBodyContains

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSubstring: (NSString *) substring
{
  self = [super init];
  __substring = [substring retain_stub];
  __substring_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"substring"])
  {
    __substring = [[decoder decodeObjectForKey: @"substring"] retain_stub];
    __substring_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__substring_isset)
  {
    [encoder encodeObject: __substring forKey: @"substring"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __substring_isset ? 2654435761 : 0;
  if (__substring_isset)
  {
    hash = (hash * 31) ^ [__substring hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherBodyContains class]]) {
    return NO;
  }
  AromaReactions_MatcherBodyContains *other = (AromaReactions_MatcherBodyContains *)anObject;
  if ((__substring_isset != other->__substring_isset) ||
      (__substring_isset && ((__substring || other->__substring) && ![__substring isEqual:other->__substring]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__substring release_stub];
  [super dealloc_stub];
}

- (NSString *) substring {
  return [[__substring retain_stub] autorelease_stub];
}

- (void) setSubstring: (NSString *) substring {
  [substring retain_stub];
  [__substring release_stub];
  __substring = substring;
  __substring_isset = YES;
}

- (BOOL) substringIsSet {
  return __substring_isset;
}

- (void) unsetSubstring {
  [__substring release_stub];
  __substring = nil;
  __substring_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubstring: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherBodyContains"];
  if (__substring_isset) {
    if (__substring != nil) {
      [outProtocol writeFieldBeginWithName: @"substring" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __substring];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherBodyContains("];
  [ms appendString: @"substring:"];
  [ms appendFormat: @"\"%@\"", __substring];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherBodyDoesNotContain

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSubstring: (NSString *) substring
{
  self = [super init];
  __substring = [substring retain_stub];
  __substring_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"substring"])
  {
    __substring = [[decoder decodeObjectForKey: @"substring"] retain_stub];
    __substring_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__substring_isset)
  {
    [encoder encodeObject: __substring forKey: @"substring"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __substring_isset ? 2654435761 : 0;
  if (__substring_isset)
  {
    hash = (hash * 31) ^ [__substring hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherBodyDoesNotContain class]]) {
    return NO;
  }
  AromaReactions_MatcherBodyDoesNotContain *other = (AromaReactions_MatcherBodyDoesNotContain *)anObject;
  if ((__substring_isset != other->__substring_isset) ||
      (__substring_isset && ((__substring || other->__substring) && ![__substring isEqual:other->__substring]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__substring release_stub];
  [super dealloc_stub];
}

- (NSString *) substring {
  return [[__substring retain_stub] autorelease_stub];
}

- (void) setSubstring: (NSString *) substring {
  [substring retain_stub];
  [__substring release_stub];
  __substring = substring;
  __substring_isset = YES;
}

- (BOOL) substringIsSet {
  return __substring_isset;
}

- (void) unsetSubstring {
  [__substring release_stub];
  __substring = nil;
  __substring_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubstring: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherBodyDoesNotContain"];
  if (__substring_isset) {
    if (__substring != nil) {
      [outProtocol writeFieldBeginWithName: @"substring" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __substring];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherBodyDoesNotContain("];
  [ms appendString: @"substring:"];
  [ms appendFormat: @"\"%@\"", __substring];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherUrgencyIs

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.possibleUrgencies = [[[NSMutableSet alloc] initWithCapacity:0] autorelease_stub];

#endif
  return self;
}

- (id) initWithPossibleUrgencies: (NSMutableSet *) possibleUrgencies
{
  self = [super init];
  __possibleUrgencies = [possibleUrgencies retain_stub];
  __possibleUrgencies_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"possibleUrgencies"])
  {
    __possibleUrgencies = [[decoder decodeObjectForKey: @"possibleUrgencies"] retain_stub];
    __possibleUrgencies_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__possibleUrgencies_isset)
  {
    [encoder encodeObject: __possibleUrgencies forKey: @"possibleUrgencies"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __possibleUrgencies_isset ? 2654435761 : 0;
  if (__possibleUrgencies_isset)
  {
    hash = (hash * 31) ^ [__possibleUrgencies hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherUrgencyIs class]]) {
    return NO;
  }
  AromaReactions_MatcherUrgencyIs *other = (AromaReactions_MatcherUrgencyIs *)anObject;
  if ((__possibleUrgencies_isset != other->__possibleUrgencies_isset) ||
      (__possibleUrgencies_isset && ((__possibleUrgencies || other->__possibleUrgencies) && ![__possibleUrgencies isEqual:other->__possibleUrgencies]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__possibleUrgencies release_stub];
  [super dealloc_stub];
}

- (NSMutableSet *) possibleUrgencies {
  return [[__possibleUrgencies retain_stub] autorelease_stub];
}

- (void) setPossibleUrgencies: (NSMutableSet *) possibleUrgencies {
  [possibleUrgencies retain_stub];
  [__possibleUrgencies release_stub];
  __possibleUrgencies = possibleUrgencies;
  __possibleUrgencies_isset = YES;
}

- (BOOL) possibleUrgenciesIsSet {
  return __possibleUrgencies_isset;
}

- (void) unsetPossibleUrgencies {
  [__possibleUrgencies release_stub];
  __possibleUrgencies = nil;
  __possibleUrgencies_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_SET) {
          int _size0;
          [inProtocol readSetBeginReturningElementType: NULL size: &_size0];
          NSMutableSet * fieldValue = [[NSMutableSet alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            int _elem2 = [inProtocol readI32];
            [fieldValue addObject: [NSNumber numberWithInt: _elem2]];
          }
          [inProtocol readSetEnd];
          [self setPossibleUrgencies: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherUrgencyIs"];
  if (__possibleUrgencies_isset) {
    if (__possibleUrgencies != nil) {
      [outProtocol writeFieldBeginWithName: @"possibleUrgencies" type: TType_SET fieldID: 1];
      {
        [outProtocol writeSetBeginWithElementType: TType_I32 size: [__possibleUrgencies count]];
        NSEnumerator * _iter3 = [__possibleUrgencies objectEnumerator];
        id obj4;
        while ((obj4 = [_iter3 nextObject]))
        {
          [outProtocol writeI32: [obj4 intValue]];
        }
        [outProtocol writeSetEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherUrgencyIs("];
  [ms appendString: @"possibleUrgencies:"];
  [ms appendFormat: @"%@", __possibleUrgencies];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherHostnameIs

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithExpectedHostname: (NSString *) expectedHostname
{
  self = [super init];
  __expectedHostname = [expectedHostname retain_stub];
  __expectedHostname_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"expectedHostname"])
  {
    __expectedHostname = [[decoder decodeObjectForKey: @"expectedHostname"] retain_stub];
    __expectedHostname_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__expectedHostname_isset)
  {
    [encoder encodeObject: __expectedHostname forKey: @"expectedHostname"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __expectedHostname_isset ? 2654435761 : 0;
  if (__expectedHostname_isset)
  {
    hash = (hash * 31) ^ [__expectedHostname hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherHostnameIs class]]) {
    return NO;
  }
  AromaReactions_MatcherHostnameIs *other = (AromaReactions_MatcherHostnameIs *)anObject;
  if ((__expectedHostname_isset != other->__expectedHostname_isset) ||
      (__expectedHostname_isset && ((__expectedHostname || other->__expectedHostname) && ![__expectedHostname isEqual:other->__expectedHostname]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__expectedHostname release_stub];
  [super dealloc_stub];
}

- (NSString *) expectedHostname {
  return [[__expectedHostname retain_stub] autorelease_stub];
}

- (void) setExpectedHostname: (NSString *) expectedHostname {
  [expectedHostname retain_stub];
  [__expectedHostname release_stub];
  __expectedHostname = expectedHostname;
  __expectedHostname_isset = YES;
}

- (BOOL) expectedHostnameIsSet {
  return __expectedHostname_isset;
}

- (void) unsetExpectedHostname {
  [__expectedHostname release_stub];
  __expectedHostname = nil;
  __expectedHostname_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setExpectedHostname: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherHostnameIs"];
  if (__expectedHostname_isset) {
    if (__expectedHostname != nil) {
      [outProtocol writeFieldBeginWithName: @"expectedHostname" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __expectedHostname];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherHostnameIs("];
  [ms appendString: @"expectedHostname:"];
  [ms appendFormat: @"\"%@\"", __expectedHostname];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherHostnameContains

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSubstring: (NSString *) substring
{
  self = [super init];
  __substring = [substring retain_stub];
  __substring_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"substring"])
  {
    __substring = [[decoder decodeObjectForKey: @"substring"] retain_stub];
    __substring_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__substring_isset)
  {
    [encoder encodeObject: __substring forKey: @"substring"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __substring_isset ? 2654435761 : 0;
  if (__substring_isset)
  {
    hash = (hash * 31) ^ [__substring hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherHostnameContains class]]) {
    return NO;
  }
  AromaReactions_MatcherHostnameContains *other = (AromaReactions_MatcherHostnameContains *)anObject;
  if ((__substring_isset != other->__substring_isset) ||
      (__substring_isset && ((__substring || other->__substring) && ![__substring isEqual:other->__substring]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__substring release_stub];
  [super dealloc_stub];
}

- (NSString *) substring {
  return [[__substring retain_stub] autorelease_stub];
}

- (void) setSubstring: (NSString *) substring {
  [substring retain_stub];
  [__substring release_stub];
  __substring = substring;
  __substring_isset = YES;
}

- (BOOL) substringIsSet {
  return __substring_isset;
}

- (void) unsetSubstring {
  [__substring release_stub];
  __substring = nil;
  __substring_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubstring: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherHostnameContains"];
  if (__substring_isset) {
    if (__substring != nil) {
      [outProtocol writeFieldBeginWithName: @"substring" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __substring];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherHostnameContains("];
  [ms appendString: @"substring:"];
  [ms appendFormat: @"\"%@\"", __substring];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherHostnameDoesNotContain

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSubstring: (NSString *) substring
{
  self = [super init];
  __substring = [substring retain_stub];
  __substring_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"substring"])
  {
    __substring = [[decoder decodeObjectForKey: @"substring"] retain_stub];
    __substring_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__substring_isset)
  {
    [encoder encodeObject: __substring forKey: @"substring"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __substring_isset ? 2654435761 : 0;
  if (__substring_isset)
  {
    hash = (hash * 31) ^ [__substring hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherHostnameDoesNotContain class]]) {
    return NO;
  }
  AromaReactions_MatcherHostnameDoesNotContain *other = (AromaReactions_MatcherHostnameDoesNotContain *)anObject;
  if ((__substring_isset != other->__substring_isset) ||
      (__substring_isset && ((__substring || other->__substring) && ![__substring isEqual:other->__substring]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__substring release_stub];
  [super dealloc_stub];
}

- (NSString *) substring {
  return [[__substring retain_stub] autorelease_stub];
}

- (void) setSubstring: (NSString *) substring {
  [substring retain_stub];
  [__substring release_stub];
  __substring = substring;
  __substring_isset = YES;
}

- (BOOL) substringIsSet {
  return __substring_isset;
}

- (void) unsetSubstring {
  [__substring release_stub];
  __substring = nil;
  __substring_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubstring: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherHostnameDoesNotContain"];
  if (__substring_isset) {
    if (__substring != nil) {
      [outProtocol writeFieldBeginWithName: @"substring" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __substring];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherHostnameDoesNotContain("];
  [ms appendString: @"substring:"];
  [ms appendFormat: @"\"%@\"", __substring];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherApplicationIs

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAppId: (AromaReactions_uuid) appId
{
  self = [super init];
  __appId = [appId retain_stub];
  __appId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"appId"])
  {
    __appId = [[decoder decodeObjectForKey: @"appId"] retain_stub];
    __appId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__appId_isset)
  {
    [encoder encodeObject: __appId forKey: @"appId"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __appId_isset ? 2654435761 : 0;
  if (__appId_isset)
  {
    hash = (hash * 31) ^ [__appId hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherApplicationIs class]]) {
    return NO;
  }
  AromaReactions_MatcherApplicationIs *other = (AromaReactions_MatcherApplicationIs *)anObject;
  if ((__appId_isset != other->__appId_isset) ||
      (__appId_isset && ((__appId || other->__appId) && ![__appId isEqual:other->__appId]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__appId release_stub];
  [super dealloc_stub];
}

- (NSString *) appId {
  return [[__appId retain_stub] autorelease_stub];
}

- (void) setAppId: (NSString *) appId {
  [appId retain_stub];
  [__appId release_stub];
  __appId = appId;
  __appId_isset = YES;
}

- (BOOL) appIdIsSet {
  return __appId_isset;
}

- (void) unsetAppId {
  [__appId release_stub];
  __appId = nil;
  __appId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherApplicationIs"];
  if (__appId_isset) {
    if (__appId != nil) {
      [outProtocol writeFieldBeginWithName: @"appId" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __appId];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherApplicationIs("];
  [ms appendString: @"appId:"];
  [ms appendFormat: @"\"%@\"", __appId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_MatcherApplicationIsNot

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAppId: (AromaReactions_uuid) appId
{
  self = [super init];
  __appId = [appId retain_stub];
  __appId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"appId"])
  {
    __appId = [[decoder decodeObjectForKey: @"appId"] retain_stub];
    __appId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__appId_isset)
  {
    [encoder encodeObject: __appId forKey: @"appId"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __appId_isset ? 2654435761 : 0;
  if (__appId_isset)
  {
    hash = (hash * 31) ^ [__appId hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_MatcherApplicationIsNot class]]) {
    return NO;
  }
  AromaReactions_MatcherApplicationIsNot *other = (AromaReactions_MatcherApplicationIsNot *)anObject;
  if ((__appId_isset != other->__appId_isset) ||
      (__appId_isset && ((__appId || other->__appId) && ![__appId isEqual:other->__appId]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__appId release_stub];
  [super dealloc_stub];
}

- (NSString *) appId {
  return [[__appId retain_stub] autorelease_stub];
}

- (void) setAppId: (NSString *) appId {
  [appId retain_stub];
  [__appId release_stub];
  __appId = appId;
  __appId_isset = YES;
}

- (BOOL) appIdIsSet {
  return __appId_isset;
}

- (void) unsetAppId {
  [__appId release_stub];
  __appId = nil;
  __appId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAppId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"MatcherApplicationIsNot"];
  if (__appId_isset) {
    if (__appId != nil) {
      [outProtocol writeFieldBeginWithName: @"appId" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __appId];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_MatcherApplicationIsNot("];
  [ms appendString: @"appId:"];
  [ms appendFormat: @"\"%@\"", __appId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_AromaMatcher

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAll: (AromaReactions_MatcherAll *) all titleIs: (AromaReactions_MatcherTitleIs *) titleIs titleIsNot: (AromaReactions_MatcherTitleIsNot *) titleIsNot titleContains: (AromaReactions_MatcherTitleContains *) titleContains titleDoesNotContain: (AromaReactions_MatcherTitleDoesNotContain *) titleDoesNotContain bodyIs: (AromaReactions_MatcherBodyIs *) bodyIs bodyContains: (AromaReactions_MatcherBodyContains *) bodyContains bodyDoesNotContain: (AromaReactions_MatcherBodyDoesNotContain *) bodyDoesNotContain urgencyEquals: (AromaReactions_MatcherUrgencyIs *) urgencyEquals hostnameIs: (AromaReactions_MatcherHostnameIs *) hostnameIs hostnameContains: (AromaReactions_MatcherHostnameContains *) hostnameContains hostnameDoesNotContain: (AromaReactions_MatcherHostnameDoesNotContain *) hostnameDoesNotContain applicationIs: (AromaReactions_MatcherApplicationIs *) applicationIs applicationIsNot: (AromaReactions_MatcherApplicationIsNot *) applicationIsNot
{
  self = [super init];
  __all = [all retain_stub];
  __all_isset = YES;
  __titleIs = [titleIs retain_stub];
  __titleIs_isset = YES;
  __titleIsNot = [titleIsNot retain_stub];
  __titleIsNot_isset = YES;
  __titleContains = [titleContains retain_stub];
  __titleContains_isset = YES;
  __titleDoesNotContain = [titleDoesNotContain retain_stub];
  __titleDoesNotContain_isset = YES;
  __bodyIs = [bodyIs retain_stub];
  __bodyIs_isset = YES;
  __bodyContains = [bodyContains retain_stub];
  __bodyContains_isset = YES;
  __bodyDoesNotContain = [bodyDoesNotContain retain_stub];
  __bodyDoesNotContain_isset = YES;
  __urgencyEquals = [urgencyEquals retain_stub];
  __urgencyEquals_isset = YES;
  __hostnameIs = [hostnameIs retain_stub];
  __hostnameIs_isset = YES;
  __hostnameContains = [hostnameContains retain_stub];
  __hostnameContains_isset = YES;
  __hostnameDoesNotContain = [hostnameDoesNotContain retain_stub];
  __hostnameDoesNotContain_isset = YES;
  __applicationIs = [applicationIs retain_stub];
  __applicationIs_isset = YES;
  __applicationIsNot = [applicationIsNot retain_stub];
  __applicationIsNot_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"all"])
  {
    __all = [[decoder decodeObjectForKey: @"all"] retain_stub];
    __all_isset = YES;
  }
  if ([decoder containsValueForKey: @"titleIs"])
  {
    __titleIs = [[decoder decodeObjectForKey: @"titleIs"] retain_stub];
    __titleIs_isset = YES;
  }
  if ([decoder containsValueForKey: @"titleIsNot"])
  {
    __titleIsNot = [[decoder decodeObjectForKey: @"titleIsNot"] retain_stub];
    __titleIsNot_isset = YES;
  }
  if ([decoder containsValueForKey: @"titleContains"])
  {
    __titleContains = [[decoder decodeObjectForKey: @"titleContains"] retain_stub];
    __titleContains_isset = YES;
  }
  if ([decoder containsValueForKey: @"titleDoesNotContain"])
  {
    __titleDoesNotContain = [[decoder decodeObjectForKey: @"titleDoesNotContain"] retain_stub];
    __titleDoesNotContain_isset = YES;
  }
  if ([decoder containsValueForKey: @"bodyIs"])
  {
    __bodyIs = [[decoder decodeObjectForKey: @"bodyIs"] retain_stub];
    __bodyIs_isset = YES;
  }
  if ([decoder containsValueForKey: @"bodyContains"])
  {
    __bodyContains = [[decoder decodeObjectForKey: @"bodyContains"] retain_stub];
    __bodyContains_isset = YES;
  }
  if ([decoder containsValueForKey: @"bodyDoesNotContain"])
  {
    __bodyDoesNotContain = [[decoder decodeObjectForKey: @"bodyDoesNotContain"] retain_stub];
    __bodyDoesNotContain_isset = YES;
  }
  if ([decoder containsValueForKey: @"urgencyEquals"])
  {
    __urgencyEquals = [[decoder decodeObjectForKey: @"urgencyEquals"] retain_stub];
    __urgencyEquals_isset = YES;
  }
  if ([decoder containsValueForKey: @"hostnameIs"])
  {
    __hostnameIs = [[decoder decodeObjectForKey: @"hostnameIs"] retain_stub];
    __hostnameIs_isset = YES;
  }
  if ([decoder containsValueForKey: @"hostnameContains"])
  {
    __hostnameContains = [[decoder decodeObjectForKey: @"hostnameContains"] retain_stub];
    __hostnameContains_isset = YES;
  }
  if ([decoder containsValueForKey: @"hostnameDoesNotContain"])
  {
    __hostnameDoesNotContain = [[decoder decodeObjectForKey: @"hostnameDoesNotContain"] retain_stub];
    __hostnameDoesNotContain_isset = YES;
  }
  if ([decoder containsValueForKey: @"applicationIs"])
  {
    __applicationIs = [[decoder decodeObjectForKey: @"applicationIs"] retain_stub];
    __applicationIs_isset = YES;
  }
  if ([decoder containsValueForKey: @"applicationIsNot"])
  {
    __applicationIsNot = [[decoder decodeObjectForKey: @"applicationIsNot"] retain_stub];
    __applicationIsNot_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__all_isset)
  {
    [encoder encodeObject: __all forKey: @"all"];
  }
  if (__titleIs_isset)
  {
    [encoder encodeObject: __titleIs forKey: @"titleIs"];
  }
  if (__titleIsNot_isset)
  {
    [encoder encodeObject: __titleIsNot forKey: @"titleIsNot"];
  }
  if (__titleContains_isset)
  {
    [encoder encodeObject: __titleContains forKey: @"titleContains"];
  }
  if (__titleDoesNotContain_isset)
  {
    [encoder encodeObject: __titleDoesNotContain forKey: @"titleDoesNotContain"];
  }
  if (__bodyIs_isset)
  {
    [encoder encodeObject: __bodyIs forKey: @"bodyIs"];
  }
  if (__bodyContains_isset)
  {
    [encoder encodeObject: __bodyContains forKey: @"bodyContains"];
  }
  if (__bodyDoesNotContain_isset)
  {
    [encoder encodeObject: __bodyDoesNotContain forKey: @"bodyDoesNotContain"];
  }
  if (__urgencyEquals_isset)
  {
    [encoder encodeObject: __urgencyEquals forKey: @"urgencyEquals"];
  }
  if (__hostnameIs_isset)
  {
    [encoder encodeObject: __hostnameIs forKey: @"hostnameIs"];
  }
  if (__hostnameContains_isset)
  {
    [encoder encodeObject: __hostnameContains forKey: @"hostnameContains"];
  }
  if (__hostnameDoesNotContain_isset)
  {
    [encoder encodeObject: __hostnameDoesNotContain forKey: @"hostnameDoesNotContain"];
  }
  if (__applicationIs_isset)
  {
    [encoder encodeObject: __applicationIs forKey: @"applicationIs"];
  }
  if (__applicationIsNot_isset)
  {
    [encoder encodeObject: __applicationIsNot forKey: @"applicationIsNot"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __all_isset ? 2654435761 : 0;
  if (__all_isset)
  {
    hash = (hash * 31) ^ [__all hash];
  }
  hash = (hash * 31) ^ __titleIs_isset ? 2654435761 : 0;
  if (__titleIs_isset)
  {
    hash = (hash * 31) ^ [__titleIs hash];
  }
  hash = (hash * 31) ^ __titleIsNot_isset ? 2654435761 : 0;
  if (__titleIsNot_isset)
  {
    hash = (hash * 31) ^ [__titleIsNot hash];
  }
  hash = (hash * 31) ^ __titleContains_isset ? 2654435761 : 0;
  if (__titleContains_isset)
  {
    hash = (hash * 31) ^ [__titleContains hash];
  }
  hash = (hash * 31) ^ __titleDoesNotContain_isset ? 2654435761 : 0;
  if (__titleDoesNotContain_isset)
  {
    hash = (hash * 31) ^ [__titleDoesNotContain hash];
  }
  hash = (hash * 31) ^ __bodyIs_isset ? 2654435761 : 0;
  if (__bodyIs_isset)
  {
    hash = (hash * 31) ^ [__bodyIs hash];
  }
  hash = (hash * 31) ^ __bodyContains_isset ? 2654435761 : 0;
  if (__bodyContains_isset)
  {
    hash = (hash * 31) ^ [__bodyContains hash];
  }
  hash = (hash * 31) ^ __bodyDoesNotContain_isset ? 2654435761 : 0;
  if (__bodyDoesNotContain_isset)
  {
    hash = (hash * 31) ^ [__bodyDoesNotContain hash];
  }
  hash = (hash * 31) ^ __urgencyEquals_isset ? 2654435761 : 0;
  if (__urgencyEquals_isset)
  {
    hash = (hash * 31) ^ [__urgencyEquals hash];
  }
  hash = (hash * 31) ^ __hostnameIs_isset ? 2654435761 : 0;
  if (__hostnameIs_isset)
  {
    hash = (hash * 31) ^ [__hostnameIs hash];
  }
  hash = (hash * 31) ^ __hostnameContains_isset ? 2654435761 : 0;
  if (__hostnameContains_isset)
  {
    hash = (hash * 31) ^ [__hostnameContains hash];
  }
  hash = (hash * 31) ^ __hostnameDoesNotContain_isset ? 2654435761 : 0;
  if (__hostnameDoesNotContain_isset)
  {
    hash = (hash * 31) ^ [__hostnameDoesNotContain hash];
  }
  hash = (hash * 31) ^ __applicationIs_isset ? 2654435761 : 0;
  if (__applicationIs_isset)
  {
    hash = (hash * 31) ^ [__applicationIs hash];
  }
  hash = (hash * 31) ^ __applicationIsNot_isset ? 2654435761 : 0;
  if (__applicationIsNot_isset)
  {
    hash = (hash * 31) ^ [__applicationIsNot hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_AromaMatcher class]]) {
    return NO;
  }
  AromaReactions_AromaMatcher *other = (AromaReactions_AromaMatcher *)anObject;
  if ((__all_isset != other->__all_isset) ||
      (__all_isset && ((__all || other->__all) && ![__all isEqual:other->__all]))) {
    return NO;
  }
  if ((__titleIs_isset != other->__titleIs_isset) ||
      (__titleIs_isset && ((__titleIs || other->__titleIs) && ![__titleIs isEqual:other->__titleIs]))) {
    return NO;
  }
  if ((__titleIsNot_isset != other->__titleIsNot_isset) ||
      (__titleIsNot_isset && ((__titleIsNot || other->__titleIsNot) && ![__titleIsNot isEqual:other->__titleIsNot]))) {
    return NO;
  }
  if ((__titleContains_isset != other->__titleContains_isset) ||
      (__titleContains_isset && ((__titleContains || other->__titleContains) && ![__titleContains isEqual:other->__titleContains]))) {
    return NO;
  }
  if ((__titleDoesNotContain_isset != other->__titleDoesNotContain_isset) ||
      (__titleDoesNotContain_isset && ((__titleDoesNotContain || other->__titleDoesNotContain) && ![__titleDoesNotContain isEqual:other->__titleDoesNotContain]))) {
    return NO;
  }
  if ((__bodyIs_isset != other->__bodyIs_isset) ||
      (__bodyIs_isset && ((__bodyIs || other->__bodyIs) && ![__bodyIs isEqual:other->__bodyIs]))) {
    return NO;
  }
  if ((__bodyContains_isset != other->__bodyContains_isset) ||
      (__bodyContains_isset && ((__bodyContains || other->__bodyContains) && ![__bodyContains isEqual:other->__bodyContains]))) {
    return NO;
  }
  if ((__bodyDoesNotContain_isset != other->__bodyDoesNotContain_isset) ||
      (__bodyDoesNotContain_isset && ((__bodyDoesNotContain || other->__bodyDoesNotContain) && ![__bodyDoesNotContain isEqual:other->__bodyDoesNotContain]))) {
    return NO;
  }
  if ((__urgencyEquals_isset != other->__urgencyEquals_isset) ||
      (__urgencyEquals_isset && ((__urgencyEquals || other->__urgencyEquals) && ![__urgencyEquals isEqual:other->__urgencyEquals]))) {
    return NO;
  }
  if ((__hostnameIs_isset != other->__hostnameIs_isset) ||
      (__hostnameIs_isset && ((__hostnameIs || other->__hostnameIs) && ![__hostnameIs isEqual:other->__hostnameIs]))) {
    return NO;
  }
  if ((__hostnameContains_isset != other->__hostnameContains_isset) ||
      (__hostnameContains_isset && ((__hostnameContains || other->__hostnameContains) && ![__hostnameContains isEqual:other->__hostnameContains]))) {
    return NO;
  }
  if ((__hostnameDoesNotContain_isset != other->__hostnameDoesNotContain_isset) ||
      (__hostnameDoesNotContain_isset && ((__hostnameDoesNotContain || other->__hostnameDoesNotContain) && ![__hostnameDoesNotContain isEqual:other->__hostnameDoesNotContain]))) {
    return NO;
  }
  if ((__applicationIs_isset != other->__applicationIs_isset) ||
      (__applicationIs_isset && ((__applicationIs || other->__applicationIs) && ![__applicationIs isEqual:other->__applicationIs]))) {
    return NO;
  }
  if ((__applicationIsNot_isset != other->__applicationIsNot_isset) ||
      (__applicationIsNot_isset && ((__applicationIsNot || other->__applicationIsNot) && ![__applicationIsNot isEqual:other->__applicationIsNot]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__all release_stub];
  [__titleIs release_stub];
  [__titleIsNot release_stub];
  [__titleContains release_stub];
  [__titleDoesNotContain release_stub];
  [__bodyIs release_stub];
  [__bodyContains release_stub];
  [__bodyDoesNotContain release_stub];
  [__urgencyEquals release_stub];
  [__hostnameIs release_stub];
  [__hostnameContains release_stub];
  [__hostnameDoesNotContain release_stub];
  [__applicationIs release_stub];
  [__applicationIsNot release_stub];
  [super dealloc_stub];
}

- (AromaReactions_MatcherAll *) all {
  return [[__all retain_stub] autorelease_stub];
}

- (void) setAll: (AromaReactions_MatcherAll *) all {
  [all retain_stub];
  [__all release_stub];
  __all = all;
  __all_isset = YES;
}

- (BOOL) allIsSet {
  return __all_isset;
}

- (void) unsetAll {
  [__all release_stub];
  __all = nil;
  __all_isset = NO;
}

- (AromaReactions_MatcherTitleIs *) titleIs {
  return [[__titleIs retain_stub] autorelease_stub];
}

- (void) setTitleIs: (AromaReactions_MatcherTitleIs *) titleIs {
  [titleIs retain_stub];
  [__titleIs release_stub];
  __titleIs = titleIs;
  __titleIs_isset = YES;
}

- (BOOL) titleIsIsSet {
  return __titleIs_isset;
}

- (void) unsetTitleIs {
  [__titleIs release_stub];
  __titleIs = nil;
  __titleIs_isset = NO;
}

- (AromaReactions_MatcherTitleIsNot *) titleIsNot {
  return [[__titleIsNot retain_stub] autorelease_stub];
}

- (void) setTitleIsNot: (AromaReactions_MatcherTitleIsNot *) titleIsNot {
  [titleIsNot retain_stub];
  [__titleIsNot release_stub];
  __titleIsNot = titleIsNot;
  __titleIsNot_isset = YES;
}

- (BOOL) titleIsNotIsSet {
  return __titleIsNot_isset;
}

- (void) unsetTitleIsNot {
  [__titleIsNot release_stub];
  __titleIsNot = nil;
  __titleIsNot_isset = NO;
}

- (AromaReactions_MatcherTitleContains *) titleContains {
  return [[__titleContains retain_stub] autorelease_stub];
}

- (void) setTitleContains: (AromaReactions_MatcherTitleContains *) titleContains {
  [titleContains retain_stub];
  [__titleContains release_stub];
  __titleContains = titleContains;
  __titleContains_isset = YES;
}

- (BOOL) titleContainsIsSet {
  return __titleContains_isset;
}

- (void) unsetTitleContains {
  [__titleContains release_stub];
  __titleContains = nil;
  __titleContains_isset = NO;
}

- (AromaReactions_MatcherTitleDoesNotContain *) titleDoesNotContain {
  return [[__titleDoesNotContain retain_stub] autorelease_stub];
}

- (void) setTitleDoesNotContain: (AromaReactions_MatcherTitleDoesNotContain *) titleDoesNotContain {
  [titleDoesNotContain retain_stub];
  [__titleDoesNotContain release_stub];
  __titleDoesNotContain = titleDoesNotContain;
  __titleDoesNotContain_isset = YES;
}

- (BOOL) titleDoesNotContainIsSet {
  return __titleDoesNotContain_isset;
}

- (void) unsetTitleDoesNotContain {
  [__titleDoesNotContain release_stub];
  __titleDoesNotContain = nil;
  __titleDoesNotContain_isset = NO;
}

- (AromaReactions_MatcherBodyIs *) bodyIs {
  return [[__bodyIs retain_stub] autorelease_stub];
}

- (void) setBodyIs: (AromaReactions_MatcherBodyIs *) bodyIs {
  [bodyIs retain_stub];
  [__bodyIs release_stub];
  __bodyIs = bodyIs;
  __bodyIs_isset = YES;
}

- (BOOL) bodyIsIsSet {
  return __bodyIs_isset;
}

- (void) unsetBodyIs {
  [__bodyIs release_stub];
  __bodyIs = nil;
  __bodyIs_isset = NO;
}

- (AromaReactions_MatcherBodyContains *) bodyContains {
  return [[__bodyContains retain_stub] autorelease_stub];
}

- (void) setBodyContains: (AromaReactions_MatcherBodyContains *) bodyContains {
  [bodyContains retain_stub];
  [__bodyContains release_stub];
  __bodyContains = bodyContains;
  __bodyContains_isset = YES;
}

- (BOOL) bodyContainsIsSet {
  return __bodyContains_isset;
}

- (void) unsetBodyContains {
  [__bodyContains release_stub];
  __bodyContains = nil;
  __bodyContains_isset = NO;
}

- (AromaReactions_MatcherBodyDoesNotContain *) bodyDoesNotContain {
  return [[__bodyDoesNotContain retain_stub] autorelease_stub];
}

- (void) setBodyDoesNotContain: (AromaReactions_MatcherBodyDoesNotContain *) bodyDoesNotContain {
  [bodyDoesNotContain retain_stub];
  [__bodyDoesNotContain release_stub];
  __bodyDoesNotContain = bodyDoesNotContain;
  __bodyDoesNotContain_isset = YES;
}

- (BOOL) bodyDoesNotContainIsSet {
  return __bodyDoesNotContain_isset;
}

- (void) unsetBodyDoesNotContain {
  [__bodyDoesNotContain release_stub];
  __bodyDoesNotContain = nil;
  __bodyDoesNotContain_isset = NO;
}

- (AromaReactions_MatcherUrgencyIs *) urgencyEquals {
  return [[__urgencyEquals retain_stub] autorelease_stub];
}

- (void) setUrgencyEquals: (AromaReactions_MatcherUrgencyIs *) urgencyEquals {
  [urgencyEquals retain_stub];
  [__urgencyEquals release_stub];
  __urgencyEquals = urgencyEquals;
  __urgencyEquals_isset = YES;
}

- (BOOL) urgencyEqualsIsSet {
  return __urgencyEquals_isset;
}

- (void) unsetUrgencyEquals {
  [__urgencyEquals release_stub];
  __urgencyEquals = nil;
  __urgencyEquals_isset = NO;
}

- (AromaReactions_MatcherHostnameIs *) hostnameIs {
  return [[__hostnameIs retain_stub] autorelease_stub];
}

- (void) setHostnameIs: (AromaReactions_MatcherHostnameIs *) hostnameIs {
  [hostnameIs retain_stub];
  [__hostnameIs release_stub];
  __hostnameIs = hostnameIs;
  __hostnameIs_isset = YES;
}

- (BOOL) hostnameIsIsSet {
  return __hostnameIs_isset;
}

- (void) unsetHostnameIs {
  [__hostnameIs release_stub];
  __hostnameIs = nil;
  __hostnameIs_isset = NO;
}

- (AromaReactions_MatcherHostnameContains *) hostnameContains {
  return [[__hostnameContains retain_stub] autorelease_stub];
}

- (void) setHostnameContains: (AromaReactions_MatcherHostnameContains *) hostnameContains {
  [hostnameContains retain_stub];
  [__hostnameContains release_stub];
  __hostnameContains = hostnameContains;
  __hostnameContains_isset = YES;
}

- (BOOL) hostnameContainsIsSet {
  return __hostnameContains_isset;
}

- (void) unsetHostnameContains {
  [__hostnameContains release_stub];
  __hostnameContains = nil;
  __hostnameContains_isset = NO;
}

- (AromaReactions_MatcherHostnameDoesNotContain *) hostnameDoesNotContain {
  return [[__hostnameDoesNotContain retain_stub] autorelease_stub];
}

- (void) setHostnameDoesNotContain: (AromaReactions_MatcherHostnameDoesNotContain *) hostnameDoesNotContain {
  [hostnameDoesNotContain retain_stub];
  [__hostnameDoesNotContain release_stub];
  __hostnameDoesNotContain = hostnameDoesNotContain;
  __hostnameDoesNotContain_isset = YES;
}

- (BOOL) hostnameDoesNotContainIsSet {
  return __hostnameDoesNotContain_isset;
}

- (void) unsetHostnameDoesNotContain {
  [__hostnameDoesNotContain release_stub];
  __hostnameDoesNotContain = nil;
  __hostnameDoesNotContain_isset = NO;
}

- (AromaReactions_MatcherApplicationIs *) applicationIs {
  return [[__applicationIs retain_stub] autorelease_stub];
}

- (void) setApplicationIs: (AromaReactions_MatcherApplicationIs *) applicationIs {
  [applicationIs retain_stub];
  [__applicationIs release_stub];
  __applicationIs = applicationIs;
  __applicationIs_isset = YES;
}

- (BOOL) applicationIsIsSet {
  return __applicationIs_isset;
}

- (void) unsetApplicationIs {
  [__applicationIs release_stub];
  __applicationIs = nil;
  __applicationIs_isset = NO;
}

- (AromaReactions_MatcherApplicationIsNot *) applicationIsNot {
  return [[__applicationIsNot retain_stub] autorelease_stub];
}

- (void) setApplicationIsNot: (AromaReactions_MatcherApplicationIsNot *) applicationIsNot {
  [applicationIsNot retain_stub];
  [__applicationIsNot release_stub];
  __applicationIsNot = applicationIsNot;
  __applicationIsNot_isset = YES;
}

- (BOOL) applicationIsNotIsSet {
  return __applicationIsNot_isset;
}

- (void) unsetApplicationIsNot {
  [__applicationIsNot release_stub];
  __applicationIsNot = nil;
  __applicationIsNot_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherAll *fieldValue = [[AromaReactions_MatcherAll alloc] init];
          [fieldValue read: inProtocol];
          [self setAll: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherTitleIs *fieldValue = [[AromaReactions_MatcherTitleIs alloc] init];
          [fieldValue read: inProtocol];
          [self setTitleIs: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherTitleIsNot *fieldValue = [[AromaReactions_MatcherTitleIsNot alloc] init];
          [fieldValue read: inProtocol];
          [self setTitleIsNot: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherTitleContains *fieldValue = [[AromaReactions_MatcherTitleContains alloc] init];
          [fieldValue read: inProtocol];
          [self setTitleContains: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherTitleDoesNotContain *fieldValue = [[AromaReactions_MatcherTitleDoesNotContain alloc] init];
          [fieldValue read: inProtocol];
          [self setTitleDoesNotContain: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherBodyIs *fieldValue = [[AromaReactions_MatcherBodyIs alloc] init];
          [fieldValue read: inProtocol];
          [self setBodyIs: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherBodyContains *fieldValue = [[AromaReactions_MatcherBodyContains alloc] init];
          [fieldValue read: inProtocol];
          [self setBodyContains: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherBodyDoesNotContain *fieldValue = [[AromaReactions_MatcherBodyDoesNotContain alloc] init];
          [fieldValue read: inProtocol];
          [self setBodyDoesNotContain: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherUrgencyIs *fieldValue = [[AromaReactions_MatcherUrgencyIs alloc] init];
          [fieldValue read: inProtocol];
          [self setUrgencyEquals: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherHostnameIs *fieldValue = [[AromaReactions_MatcherHostnameIs alloc] init];
          [fieldValue read: inProtocol];
          [self setHostnameIs: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherHostnameContains *fieldValue = [[AromaReactions_MatcherHostnameContains alloc] init];
          [fieldValue read: inProtocol];
          [self setHostnameContains: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherHostnameDoesNotContain *fieldValue = [[AromaReactions_MatcherHostnameDoesNotContain alloc] init];
          [fieldValue read: inProtocol];
          [self setHostnameDoesNotContain: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 13:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherApplicationIs *fieldValue = [[AromaReactions_MatcherApplicationIs alloc] init];
          [fieldValue read: inProtocol];
          [self setApplicationIs: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_STRUCT) {
          AromaReactions_MatcherApplicationIsNot *fieldValue = [[AromaReactions_MatcherApplicationIsNot alloc] init];
          [fieldValue read: inProtocol];
          [self setApplicationIsNot: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AromaMatcher"];
  if (__all_isset) {
    if (__all != nil) {
      [outProtocol writeFieldBeginWithName: @"all" type: TType_STRUCT fieldID: 1];
      [__all write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__titleIs_isset) {
    if (__titleIs != nil) {
      [outProtocol writeFieldBeginWithName: @"titleIs" type: TType_STRUCT fieldID: 2];
      [__titleIs write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__titleIsNot_isset) {
    if (__titleIsNot != nil) {
      [outProtocol writeFieldBeginWithName: @"titleIsNot" type: TType_STRUCT fieldID: 3];
      [__titleIsNot write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__titleContains_isset) {
    if (__titleContains != nil) {
      [outProtocol writeFieldBeginWithName: @"titleContains" type: TType_STRUCT fieldID: 4];
      [__titleContains write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__titleDoesNotContain_isset) {
    if (__titleDoesNotContain != nil) {
      [outProtocol writeFieldBeginWithName: @"titleDoesNotContain" type: TType_STRUCT fieldID: 5];
      [__titleDoesNotContain write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__bodyIs_isset) {
    if (__bodyIs != nil) {
      [outProtocol writeFieldBeginWithName: @"bodyIs" type: TType_STRUCT fieldID: 6];
      [__bodyIs write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__bodyContains_isset) {
    if (__bodyContains != nil) {
      [outProtocol writeFieldBeginWithName: @"bodyContains" type: TType_STRUCT fieldID: 7];
      [__bodyContains write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__bodyDoesNotContain_isset) {
    if (__bodyDoesNotContain != nil) {
      [outProtocol writeFieldBeginWithName: @"bodyDoesNotContain" type: TType_STRUCT fieldID: 8];
      [__bodyDoesNotContain write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__urgencyEquals_isset) {
    if (__urgencyEquals != nil) {
      [outProtocol writeFieldBeginWithName: @"urgencyEquals" type: TType_STRUCT fieldID: 9];
      [__urgencyEquals write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__hostnameIs_isset) {
    if (__hostnameIs != nil) {
      [outProtocol writeFieldBeginWithName: @"hostnameIs" type: TType_STRUCT fieldID: 10];
      [__hostnameIs write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__hostnameContains_isset) {
    if (__hostnameContains != nil) {
      [outProtocol writeFieldBeginWithName: @"hostnameContains" type: TType_STRUCT fieldID: 11];
      [__hostnameContains write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__hostnameDoesNotContain_isset) {
    if (__hostnameDoesNotContain != nil) {
      [outProtocol writeFieldBeginWithName: @"hostnameDoesNotContain" type: TType_STRUCT fieldID: 12];
      [__hostnameDoesNotContain write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__applicationIs_isset) {
    if (__applicationIs != nil) {
      [outProtocol writeFieldBeginWithName: @"applicationIs" type: TType_STRUCT fieldID: 13];
      [__applicationIs write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__applicationIsNot_isset) {
    if (__applicationIsNot != nil) {
      [outProtocol writeFieldBeginWithName: @"applicationIsNot" type: TType_STRUCT fieldID: 14];
      [__applicationIsNot write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_AromaMatcher("];
  [ms appendString: @"all:"];
  [ms appendFormat: @"%@", __all];
  [ms appendString: @",titleIs:"];
  [ms appendFormat: @"%@", __titleIs];
  [ms appendString: @",titleIsNot:"];
  [ms appendFormat: @"%@", __titleIsNot];
  [ms appendString: @",titleContains:"];
  [ms appendFormat: @"%@", __titleContains];
  [ms appendString: @",titleDoesNotContain:"];
  [ms appendFormat: @"%@", __titleDoesNotContain];
  [ms appendString: @",bodyIs:"];
  [ms appendFormat: @"%@", __bodyIs];
  [ms appendString: @",bodyContains:"];
  [ms appendFormat: @"%@", __bodyContains];
  [ms appendString: @",bodyDoesNotContain:"];
  [ms appendFormat: @"%@", __bodyDoesNotContain];
  [ms appendString: @",urgencyEquals:"];
  [ms appendFormat: @"%@", __urgencyEquals];
  [ms appendString: @",hostnameIs:"];
  [ms appendFormat: @"%@", __hostnameIs];
  [ms appendString: @",hostnameContains:"];
  [ms appendFormat: @"%@", __hostnameContains];
  [ms appendString: @",hostnameDoesNotContain:"];
  [ms appendFormat: @"%@", __hostnameDoesNotContain];
  [ms appendString: @",applicationIs:"];
  [ms appendFormat: @"%@", __applicationIs];
  [ms appendString: @",applicationIsNot:"];
  [ms appendFormat: @"%@", __applicationIsNot];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionForwardToSlackChannel

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.includeBody = YES;

#endif
  return self;
}

- (id) initWithSlackChannel: (NSString *) slackChannel includeBody: (BOOL) includeBody webhookUrl: (NSString *) webhookUrl domainName: (NSString *) domainName
{
  self = [super init];
  __slackChannel = [slackChannel retain_stub];
  __slackChannel_isset = YES;
  __includeBody = includeBody;
  __includeBody_isset = YES;
  __webhookUrl = [webhookUrl retain_stub];
  __webhookUrl_isset = YES;
  __domainName = [domainName retain_stub];
  __domainName_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"slackChannel"])
  {
    __slackChannel = [[decoder decodeObjectForKey: @"slackChannel"] retain_stub];
    __slackChannel_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeBody"])
  {
    __includeBody = [decoder decodeBoolForKey: @"includeBody"];
    __includeBody_isset = YES;
  }
  if ([decoder containsValueForKey: @"webhookUrl"])
  {
    __webhookUrl = [[decoder decodeObjectForKey: @"webhookUrl"] retain_stub];
    __webhookUrl_isset = YES;
  }
  if ([decoder containsValueForKey: @"domainName"])
  {
    __domainName = [[decoder decodeObjectForKey: @"domainName"] retain_stub];
    __domainName_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__slackChannel_isset)
  {
    [encoder encodeObject: __slackChannel forKey: @"slackChannel"];
  }
  if (__includeBody_isset)
  {
    [encoder encodeBool: __includeBody forKey: @"includeBody"];
  }
  if (__webhookUrl_isset)
  {
    [encoder encodeObject: __webhookUrl forKey: @"webhookUrl"];
  }
  if (__domainName_isset)
  {
    [encoder encodeObject: __domainName forKey: @"domainName"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __slackChannel_isset ? 2654435761 : 0;
  if (__slackChannel_isset)
  {
    hash = (hash * 31) ^ [__slackChannel hash];
  }
  hash = (hash * 31) ^ __includeBody_isset ? 2654435761 : 0;
  if (__includeBody_isset)
  {
    hash = (hash * 31) ^ [@(__includeBody) hash];
  }
  hash = (hash * 31) ^ __webhookUrl_isset ? 2654435761 : 0;
  if (__webhookUrl_isset)
  {
    hash = (hash * 31) ^ [__webhookUrl hash];
  }
  hash = (hash * 31) ^ __domainName_isset ? 2654435761 : 0;
  if (__domainName_isset)
  {
    hash = (hash * 31) ^ [__domainName hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionForwardToSlackChannel class]]) {
    return NO;
  }
  AromaReactions_ActionForwardToSlackChannel *other = (AromaReactions_ActionForwardToSlackChannel *)anObject;
  if ((__slackChannel_isset != other->__slackChannel_isset) ||
      (__slackChannel_isset && ((__slackChannel || other->__slackChannel) && ![__slackChannel isEqual:other->__slackChannel]))) {
    return NO;
  }
  if ((__includeBody_isset != other->__includeBody_isset) ||
      (__includeBody_isset && (__includeBody != other->__includeBody))) {
    return NO;
  }
  if ((__webhookUrl_isset != other->__webhookUrl_isset) ||
      (__webhookUrl_isset && ((__webhookUrl || other->__webhookUrl) && ![__webhookUrl isEqual:other->__webhookUrl]))) {
    return NO;
  }
  if ((__domainName_isset != other->__domainName_isset) ||
      (__domainName_isset && ((__domainName || other->__domainName) && ![__domainName isEqual:other->__domainName]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__slackChannel release_stub];
  [__webhookUrl release_stub];
  [__domainName release_stub];
  [super dealloc_stub];
}

- (NSString *) slackChannel {
  return [[__slackChannel retain_stub] autorelease_stub];
}

- (void) setSlackChannel: (NSString *) slackChannel {
  [slackChannel retain_stub];
  [__slackChannel release_stub];
  __slackChannel = slackChannel;
  __slackChannel_isset = YES;
}

- (BOOL) slackChannelIsSet {
  return __slackChannel_isset;
}

- (void) unsetSlackChannel {
  [__slackChannel release_stub];
  __slackChannel = nil;
  __slackChannel_isset = NO;
}

- (BOOL) includeBody {
  return __includeBody;
}

- (void) setIncludeBody: (BOOL) includeBody {
  __includeBody = includeBody;
  __includeBody_isset = YES;
}

- (BOOL) includeBodyIsSet {
  return __includeBody_isset;
}

- (void) unsetIncludeBody {
  __includeBody_isset = NO;
}

- (NSString *) webhookUrl {
  return [[__webhookUrl retain_stub] autorelease_stub];
}

- (void) setWebhookUrl: (NSString *) webhookUrl {
  [webhookUrl retain_stub];
  [__webhookUrl release_stub];
  __webhookUrl = webhookUrl;
  __webhookUrl_isset = YES;
}

- (BOOL) webhookUrlIsSet {
  return __webhookUrl_isset;
}

- (void) unsetWebhookUrl {
  [__webhookUrl release_stub];
  __webhookUrl = nil;
  __webhookUrl_isset = NO;
}

- (NSString *) domainName {
  return [[__domainName retain_stub] autorelease_stub];
}

- (void) setDomainName: (NSString *) domainName {
  [domainName retain_stub];
  [__domainName release_stub];
  __domainName = domainName;
  __domainName_isset = YES;
}

- (BOOL) domainNameIsSet {
  return __domainName_isset;
}

- (void) unsetDomainName {
  [__domainName release_stub];
  __domainName = nil;
  __domainName_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSlackChannel: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeBody: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setWebhookUrl: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDomainName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionForwardToSlackChannel"];
  if (__slackChannel_isset) {
    if (__slackChannel != nil) {
      [outProtocol writeFieldBeginWithName: @"slackChannel" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __slackChannel];
      [outProtocol writeFieldEnd];
    }
  }
  if (__includeBody_isset) {
    [outProtocol writeFieldBeginWithName: @"includeBody" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeBody];
    [outProtocol writeFieldEnd];
  }
  if (__webhookUrl_isset) {
    if (__webhookUrl != nil) {
      [outProtocol writeFieldBeginWithName: @"webhookUrl" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __webhookUrl];
      [outProtocol writeFieldEnd];
    }
  }
  if (__domainName_isset) {
    if (__domainName != nil) {
      [outProtocol writeFieldBeginWithName: @"domainName" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __domainName];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionForwardToSlackChannel("];
  [ms appendString: @"slackChannel:"];
  [ms appendFormat: @"\"%@\"", __slackChannel];
  [ms appendString: @",includeBody:"];
  [ms appendFormat: @"%i", __includeBody];
  [ms appendString: @",webhookUrl:"];
  [ms appendFormat: @"\"%@\"", __webhookUrl];
  [ms appendString: @",domainName:"];
  [ms appendFormat: @"\"%@\"", __domainName];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionForwardToSlackUser

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.includeBody = YES;

#endif
  return self;
}

- (id) initWithSlackUsername: (NSString *) slackUsername includeBody: (BOOL) includeBody webhookUrl: (NSString *) webhookUrl domainName: (NSString *) domainName
{
  self = [super init];
  __slackUsername = [slackUsername retain_stub];
  __slackUsername_isset = YES;
  __includeBody = includeBody;
  __includeBody_isset = YES;
  __webhookUrl = [webhookUrl retain_stub];
  __webhookUrl_isset = YES;
  __domainName = [domainName retain_stub];
  __domainName_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"slackUsername"])
  {
    __slackUsername = [[decoder decodeObjectForKey: @"slackUsername"] retain_stub];
    __slackUsername_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeBody"])
  {
    __includeBody = [decoder decodeBoolForKey: @"includeBody"];
    __includeBody_isset = YES;
  }
  if ([decoder containsValueForKey: @"webhookUrl"])
  {
    __webhookUrl = [[decoder decodeObjectForKey: @"webhookUrl"] retain_stub];
    __webhookUrl_isset = YES;
  }
  if ([decoder containsValueForKey: @"domainName"])
  {
    __domainName = [[decoder decodeObjectForKey: @"domainName"] retain_stub];
    __domainName_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__slackUsername_isset)
  {
    [encoder encodeObject: __slackUsername forKey: @"slackUsername"];
  }
  if (__includeBody_isset)
  {
    [encoder encodeBool: __includeBody forKey: @"includeBody"];
  }
  if (__webhookUrl_isset)
  {
    [encoder encodeObject: __webhookUrl forKey: @"webhookUrl"];
  }
  if (__domainName_isset)
  {
    [encoder encodeObject: __domainName forKey: @"domainName"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __slackUsername_isset ? 2654435761 : 0;
  if (__slackUsername_isset)
  {
    hash = (hash * 31) ^ [__slackUsername hash];
  }
  hash = (hash * 31) ^ __includeBody_isset ? 2654435761 : 0;
  if (__includeBody_isset)
  {
    hash = (hash * 31) ^ [@(__includeBody) hash];
  }
  hash = (hash * 31) ^ __webhookUrl_isset ? 2654435761 : 0;
  if (__webhookUrl_isset)
  {
    hash = (hash * 31) ^ [__webhookUrl hash];
  }
  hash = (hash * 31) ^ __domainName_isset ? 2654435761 : 0;
  if (__domainName_isset)
  {
    hash = (hash * 31) ^ [__domainName hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionForwardToSlackUser class]]) {
    return NO;
  }
  AromaReactions_ActionForwardToSlackUser *other = (AromaReactions_ActionForwardToSlackUser *)anObject;
  if ((__slackUsername_isset != other->__slackUsername_isset) ||
      (__slackUsername_isset && ((__slackUsername || other->__slackUsername) && ![__slackUsername isEqual:other->__slackUsername]))) {
    return NO;
  }
  if ((__includeBody_isset != other->__includeBody_isset) ||
      (__includeBody_isset && (__includeBody != other->__includeBody))) {
    return NO;
  }
  if ((__webhookUrl_isset != other->__webhookUrl_isset) ||
      (__webhookUrl_isset && ((__webhookUrl || other->__webhookUrl) && ![__webhookUrl isEqual:other->__webhookUrl]))) {
    return NO;
  }
  if ((__domainName_isset != other->__domainName_isset) ||
      (__domainName_isset && ((__domainName || other->__domainName) && ![__domainName isEqual:other->__domainName]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__slackUsername release_stub];
  [__webhookUrl release_stub];
  [__domainName release_stub];
  [super dealloc_stub];
}

- (NSString *) slackUsername {
  return [[__slackUsername retain_stub] autorelease_stub];
}

- (void) setSlackUsername: (NSString *) slackUsername {
  [slackUsername retain_stub];
  [__slackUsername release_stub];
  __slackUsername = slackUsername;
  __slackUsername_isset = YES;
}

- (BOOL) slackUsernameIsSet {
  return __slackUsername_isset;
}

- (void) unsetSlackUsername {
  [__slackUsername release_stub];
  __slackUsername = nil;
  __slackUsername_isset = NO;
}

- (BOOL) includeBody {
  return __includeBody;
}

- (void) setIncludeBody: (BOOL) includeBody {
  __includeBody = includeBody;
  __includeBody_isset = YES;
}

- (BOOL) includeBodyIsSet {
  return __includeBody_isset;
}

- (void) unsetIncludeBody {
  __includeBody_isset = NO;
}

- (NSString *) webhookUrl {
  return [[__webhookUrl retain_stub] autorelease_stub];
}

- (void) setWebhookUrl: (NSString *) webhookUrl {
  [webhookUrl retain_stub];
  [__webhookUrl release_stub];
  __webhookUrl = webhookUrl;
  __webhookUrl_isset = YES;
}

- (BOOL) webhookUrlIsSet {
  return __webhookUrl_isset;
}

- (void) unsetWebhookUrl {
  [__webhookUrl release_stub];
  __webhookUrl = nil;
  __webhookUrl_isset = NO;
}

- (NSString *) domainName {
  return [[__domainName retain_stub] autorelease_stub];
}

- (void) setDomainName: (NSString *) domainName {
  [domainName retain_stub];
  [__domainName release_stub];
  __domainName = domainName;
  __domainName_isset = YES;
}

- (BOOL) domainNameIsSet {
  return __domainName_isset;
}

- (void) unsetDomainName {
  [__domainName release_stub];
  __domainName = nil;
  __domainName_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSlackUsername: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeBody: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setWebhookUrl: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDomainName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionForwardToSlackUser"];
  if (__slackUsername_isset) {
    if (__slackUsername != nil) {
      [outProtocol writeFieldBeginWithName: @"slackUsername" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __slackUsername];
      [outProtocol writeFieldEnd];
    }
  }
  if (__includeBody_isset) {
    [outProtocol writeFieldBeginWithName: @"includeBody" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeBody];
    [outProtocol writeFieldEnd];
  }
  if (__webhookUrl_isset) {
    if (__webhookUrl != nil) {
      [outProtocol writeFieldBeginWithName: @"webhookUrl" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __webhookUrl];
      [outProtocol writeFieldEnd];
    }
  }
  if (__domainName_isset) {
    if (__domainName != nil) {
      [outProtocol writeFieldBeginWithName: @"domainName" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __domainName];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionForwardToSlackUser("];
  [ms appendString: @"slackUsername:"];
  [ms appendFormat: @"\"%@\"", __slackUsername];
  [ms appendString: @",includeBody:"];
  [ms appendFormat: @"%i", __includeBody];
  [ms appendString: @",webhookUrl:"];
  [ms appendFormat: @"\"%@\"", __webhookUrl];
  [ms appendString: @",domainName:"];
  [ms appendFormat: @"\"%@\"", __domainName];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionForwardToGitter

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.includeBody = YES;

#endif
  return self;
}

- (id) initWithGitterWebhookUrl: (NSString *) gitterWebhookUrl includeBody: (BOOL) includeBody
{
  self = [super init];
  __gitterWebhookUrl = [gitterWebhookUrl retain_stub];
  __gitterWebhookUrl_isset = YES;
  __includeBody = includeBody;
  __includeBody_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"gitterWebhookUrl"])
  {
    __gitterWebhookUrl = [[decoder decodeObjectForKey: @"gitterWebhookUrl"] retain_stub];
    __gitterWebhookUrl_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeBody"])
  {
    __includeBody = [decoder decodeBoolForKey: @"includeBody"];
    __includeBody_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__gitterWebhookUrl_isset)
  {
    [encoder encodeObject: __gitterWebhookUrl forKey: @"gitterWebhookUrl"];
  }
  if (__includeBody_isset)
  {
    [encoder encodeBool: __includeBody forKey: @"includeBody"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __gitterWebhookUrl_isset ? 2654435761 : 0;
  if (__gitterWebhookUrl_isset)
  {
    hash = (hash * 31) ^ [__gitterWebhookUrl hash];
  }
  hash = (hash * 31) ^ __includeBody_isset ? 2654435761 : 0;
  if (__includeBody_isset)
  {
    hash = (hash * 31) ^ [@(__includeBody) hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionForwardToGitter class]]) {
    return NO;
  }
  AromaReactions_ActionForwardToGitter *other = (AromaReactions_ActionForwardToGitter *)anObject;
  if ((__gitterWebhookUrl_isset != other->__gitterWebhookUrl_isset) ||
      (__gitterWebhookUrl_isset && ((__gitterWebhookUrl || other->__gitterWebhookUrl) && ![__gitterWebhookUrl isEqual:other->__gitterWebhookUrl]))) {
    return NO;
  }
  if ((__includeBody_isset != other->__includeBody_isset) ||
      (__includeBody_isset && (__includeBody != other->__includeBody))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__gitterWebhookUrl release_stub];
  [super dealloc_stub];
}

- (NSString *) gitterWebhookUrl {
  return [[__gitterWebhookUrl retain_stub] autorelease_stub];
}

- (void) setGitterWebhookUrl: (NSString *) gitterWebhookUrl {
  [gitterWebhookUrl retain_stub];
  [__gitterWebhookUrl release_stub];
  __gitterWebhookUrl = gitterWebhookUrl;
  __gitterWebhookUrl_isset = YES;
}

- (BOOL) gitterWebhookUrlIsSet {
  return __gitterWebhookUrl_isset;
}

- (void) unsetGitterWebhookUrl {
  [__gitterWebhookUrl release_stub];
  __gitterWebhookUrl = nil;
  __gitterWebhookUrl_isset = NO;
}

- (BOOL) includeBody {
  return __includeBody;
}

- (void) setIncludeBody: (BOOL) includeBody {
  __includeBody = includeBody;
  __includeBody_isset = YES;
}

- (BOOL) includeBodyIsSet {
  return __includeBody_isset;
}

- (void) unsetIncludeBody {
  __includeBody_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGitterWebhookUrl: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeBody: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionForwardToGitter"];
  if (__gitterWebhookUrl_isset) {
    if (__gitterWebhookUrl != nil) {
      [outProtocol writeFieldBeginWithName: @"gitterWebhookUrl" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __gitterWebhookUrl];
      [outProtocol writeFieldEnd];
    }
  }
  if (__includeBody_isset) {
    [outProtocol writeFieldBeginWithName: @"includeBody" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeBody];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionForwardToGitter("];
  [ms appendString: @"gitterWebhookUrl:"];
  [ms appendFormat: @"\"%@\"", __gitterWebhookUrl];
  [ms appendString: @",includeBody:"];
  [ms appendFormat: @"%i", __includeBody];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionSendEmail

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.includeBody = YES;

#endif
  return self;
}

- (id) initWithEmailAddress: (NSString *) emailAddress includeBody: (BOOL) includeBody
{
  self = [super init];
  __emailAddress = [emailAddress retain_stub];
  __emailAddress_isset = YES;
  __includeBody = includeBody;
  __includeBody_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"emailAddress"])
  {
    __emailAddress = [[decoder decodeObjectForKey: @"emailAddress"] retain_stub];
    __emailAddress_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeBody"])
  {
    __includeBody = [decoder decodeBoolForKey: @"includeBody"];
    __includeBody_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__emailAddress_isset)
  {
    [encoder encodeObject: __emailAddress forKey: @"emailAddress"];
  }
  if (__includeBody_isset)
  {
    [encoder encodeBool: __includeBody forKey: @"includeBody"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __emailAddress_isset ? 2654435761 : 0;
  if (__emailAddress_isset)
  {
    hash = (hash * 31) ^ [__emailAddress hash];
  }
  hash = (hash * 31) ^ __includeBody_isset ? 2654435761 : 0;
  if (__includeBody_isset)
  {
    hash = (hash * 31) ^ [@(__includeBody) hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionSendEmail class]]) {
    return NO;
  }
  AromaReactions_ActionSendEmail *other = (AromaReactions_ActionSendEmail *)anObject;
  if ((__emailAddress_isset != other->__emailAddress_isset) ||
      (__emailAddress_isset && ((__emailAddress || other->__emailAddress) && ![__emailAddress isEqual:other->__emailAddress]))) {
    return NO;
  }
  if ((__includeBody_isset != other->__includeBody_isset) ||
      (__includeBody_isset && (__includeBody != other->__includeBody))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__emailAddress release_stub];
  [super dealloc_stub];
}

- (NSString *) emailAddress {
  return [[__emailAddress retain_stub] autorelease_stub];
}

- (void) setEmailAddress: (NSString *) emailAddress {
  [emailAddress retain_stub];
  [__emailAddress release_stub];
  __emailAddress = emailAddress;
  __emailAddress_isset = YES;
}

- (BOOL) emailAddressIsSet {
  return __emailAddress_isset;
}

- (void) unsetEmailAddress {
  [__emailAddress release_stub];
  __emailAddress = nil;
  __emailAddress_isset = NO;
}

- (BOOL) includeBody {
  return __includeBody;
}

- (void) setIncludeBody: (BOOL) includeBody {
  __includeBody = includeBody;
  __includeBody_isset = YES;
}

- (BOOL) includeBodyIsSet {
  return __includeBody_isset;
}

- (void) unsetIncludeBody {
  __includeBody_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setEmailAddress: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeBody: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionSendEmail"];
  if (__emailAddress_isset) {
    if (__emailAddress != nil) {
      [outProtocol writeFieldBeginWithName: @"emailAddress" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __emailAddress];
      [outProtocol writeFieldEnd];
    }
  }
  if (__includeBody_isset) {
    [outProtocol writeFieldBeginWithName: @"includeBody" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeBody];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionSendEmail("];
  [ms appendString: @"emailAddress:"];
  [ms appendFormat: @"\"%@\"", __emailAddress];
  [ms appendString: @",includeBody:"];
  [ms appendFormat: @"%i", __includeBody];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionSkipInbox

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionSkipInbox class]]) {
    return NO;
  }
  AromaReactions_ActionSkipInbox *other = (AromaReactions_ActionSkipInbox *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionSkipInbox"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionSkipInbox("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionDontStoreMessage

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionDontStoreMessage class]]) {
    return NO;
  }
  AromaReactions_ActionDontStoreMessage *other = (AromaReactions_ActionDontStoreMessage *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionDontStoreMessage"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionDontStoreMessage("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionRespondWithMessage

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithMessageToRespondWith: (NSString *) messageToRespondWith
{
  self = [super init];
  __messageToRespondWith = [messageToRespondWith retain_stub];
  __messageToRespondWith_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"messageToRespondWith"])
  {
    __messageToRespondWith = [[decoder decodeObjectForKey: @"messageToRespondWith"] retain_stub];
    __messageToRespondWith_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__messageToRespondWith_isset)
  {
    [encoder encodeObject: __messageToRespondWith forKey: @"messageToRespondWith"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __messageToRespondWith_isset ? 2654435761 : 0;
  if (__messageToRespondWith_isset)
  {
    hash = (hash * 31) ^ [__messageToRespondWith hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionRespondWithMessage class]]) {
    return NO;
  }
  AromaReactions_ActionRespondWithMessage *other = (AromaReactions_ActionRespondWithMessage *)anObject;
  if ((__messageToRespondWith_isset != other->__messageToRespondWith_isset) ||
      (__messageToRespondWith_isset && ((__messageToRespondWith || other->__messageToRespondWith) && ![__messageToRespondWith isEqual:other->__messageToRespondWith]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__messageToRespondWith release_stub];
  [super dealloc_stub];
}

- (NSString *) messageToRespondWith {
  return [[__messageToRespondWith retain_stub] autorelease_stub];
}

- (void) setMessageToRespondWith: (NSString *) messageToRespondWith {
  [messageToRespondWith retain_stub];
  [__messageToRespondWith release_stub];
  __messageToRespondWith = messageToRespondWith;
  __messageToRespondWith_isset = YES;
}

- (BOOL) messageToRespondWithIsSet {
  return __messageToRespondWith_isset;
}

- (void) unsetMessageToRespondWith {
  [__messageToRespondWith release_stub];
  __messageToRespondWith = nil;
  __messageToRespondWith_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessageToRespondWith: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionRespondWithMessage"];
  if (__messageToRespondWith_isset) {
    if (__messageToRespondWith != nil) {
      [outProtocol writeFieldBeginWithName: @"messageToRespondWith" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __messageToRespondWith];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionRespondWithMessage("];
  [ms appendString: @"messageToRespondWith:"];
  [ms appendFormat: @"\"%@\"", __messageToRespondWith];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionForwardToUsers

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.userIds = [[[NSMutableArray alloc] initWithCapacity:0] autorelease_stub];

#endif
  return self;
}

- (id) initWithUserIds: (NSMutableArray *) userIds
{
  self = [super init];
  __userIds = [userIds retain_stub];
  __userIds_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userIds"])
  {
    __userIds = [[decoder decodeObjectForKey: @"userIds"] retain_stub];
    __userIds_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userIds_isset)
  {
    [encoder encodeObject: __userIds forKey: @"userIds"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __userIds_isset ? 2654435761 : 0;
  if (__userIds_isset)
  {
    hash = (hash * 31) ^ [__userIds hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionForwardToUsers class]]) {
    return NO;
  }
  AromaReactions_ActionForwardToUsers *other = (AromaReactions_ActionForwardToUsers *)anObject;
  if ((__userIds_isset != other->__userIds_isset) ||
      (__userIds_isset && ((__userIds || other->__userIds) && ![__userIds isEqual:other->__userIds]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__userIds release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) userIds {
  return [[__userIds retain_stub] autorelease_stub];
}

- (void) setUserIds: (NSMutableArray *) userIds {
  [userIds retain_stub];
  [__userIds release_stub];
  __userIds = userIds;
  __userIds_isset = YES;
}

- (BOOL) userIdsIsSet {
  return __userIds_isset;
}

- (void) unsetUserIds {
  [__userIds release_stub];
  __userIds = nil;
  __userIds_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_LIST) {
          int _size5;
          [inProtocol readListBeginReturningElementType: NULL size: &_size5];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size5];
          int _i6;
          for (_i6 = 0; _i6 < _size5; ++_i6)
          {
            NSString * _elem7 = [inProtocol readString];
            [fieldValue addObject: _elem7];
          }
          [inProtocol readListEnd];
          [self setUserIds: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionForwardToUsers"];
  if (__userIds_isset) {
    if (__userIds != nil) {
      [outProtocol writeFieldBeginWithName: @"userIds" type: TType_LIST fieldID: 1];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__userIds count]];
        int idx9;
        for (idx9 = 0; idx9 < [__userIds count]; idx9++)
        {
          [outProtocol writeString: [__userIds objectAtIndex: idx9]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionForwardToUsers("];
  [ms appendString: @"userIds:"];
  [ms appendFormat: @"%@", __userIds];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionSendPushNotification

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionSendPushNotification class]]) {
    return NO;
  }
  AromaReactions_ActionSendPushNotification *other = (AromaReactions_ActionSendPushNotification *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionSendPushNotification"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionSendPushNotification("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_ActionDontSendPushNotification

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_ActionDontSendPushNotification class]]) {
    return NO;
  }
  AromaReactions_ActionDontSendPushNotification *other = (AromaReactions_ActionDontSendPushNotification *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ActionDontSendPushNotification"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_ActionDontSendPushNotification("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_AromaAction

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithForwardToSlackChannel: (AromaReactions_ActionForwardToSlackChannel *) forwardToSlackChannel forwardToSlackUser: (AromaReactions_ActionForwardToSlackUser *) forwardToSlackUser forwardToGitter: (AromaReactions_ActionForwardToGitter *) forwardToGitter sendEmail: (AromaReactions_ActionSendEmail *) sendEmail skipInbox: (AromaReactions_ActionSkipInbox *) skipInbox dontStoreMessage: (AromaReactions_ActionDontStoreMessage *) dontStoreMessage responseWithMessage: (AromaReactions_ActionRespondWithMessage *) responseWithMessage forwardToUsers: (AromaReactions_ActionForwardToUsers *) forwardToUsers sendPushNotification: (AromaReactions_ActionSendPushNotification *) sendPushNotification dontSendPushNotification: (AromaReactions_ActionDontSendPushNotification *) dontSendPushNotification
{
  self = [super init];
  __forwardToSlackChannel = [forwardToSlackChannel retain_stub];
  __forwardToSlackChannel_isset = YES;
  __forwardToSlackUser = [forwardToSlackUser retain_stub];
  __forwardToSlackUser_isset = YES;
  __forwardToGitter = [forwardToGitter retain_stub];
  __forwardToGitter_isset = YES;
  __sendEmail = [sendEmail retain_stub];
  __sendEmail_isset = YES;
  __skipInbox = [skipInbox retain_stub];
  __skipInbox_isset = YES;
  __dontStoreMessage = [dontStoreMessage retain_stub];
  __dontStoreMessage_isset = YES;
  __responseWithMessage = [responseWithMessage retain_stub];
  __responseWithMessage_isset = YES;
  __forwardToUsers = [forwardToUsers retain_stub];
  __forwardToUsers_isset = YES;
  __sendPushNotification = [sendPushNotification retain_stub];
  __sendPushNotification_isset = YES;
  __dontSendPushNotification = [dontSendPushNotification retain_stub];
  __dontSendPushNotification_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"forwardToSlackChannel"])
  {
    __forwardToSlackChannel = [[decoder decodeObjectForKey: @"forwardToSlackChannel"] retain_stub];
    __forwardToSlackChannel_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardToSlackUser"])
  {
    __forwardToSlackUser = [[decoder decodeObjectForKey: @"forwardToSlackUser"] retain_stub];
    __forwardToSlackUser_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardToGitter"])
  {
    __forwardToGitter = [[decoder decodeObjectForKey: @"forwardToGitter"] retain_stub];
    __forwardToGitter_isset = YES;
  }
  if ([decoder containsValueForKey: @"sendEmail"])
  {
    __sendEmail = [[decoder decodeObjectForKey: @"sendEmail"] retain_stub];
    __sendEmail_isset = YES;
  }
  if ([decoder containsValueForKey: @"skipInbox"])
  {
    __skipInbox = [[decoder decodeObjectForKey: @"skipInbox"] retain_stub];
    __skipInbox_isset = YES;
  }
  if ([decoder containsValueForKey: @"dontStoreMessage"])
  {
    __dontStoreMessage = [[decoder decodeObjectForKey: @"dontStoreMessage"] retain_stub];
    __dontStoreMessage_isset = YES;
  }
  if ([decoder containsValueForKey: @"responseWithMessage"])
  {
    __responseWithMessage = [[decoder decodeObjectForKey: @"responseWithMessage"] retain_stub];
    __responseWithMessage_isset = YES;
  }
  if ([decoder containsValueForKey: @"forwardToUsers"])
  {
    __forwardToUsers = [[decoder decodeObjectForKey: @"forwardToUsers"] retain_stub];
    __forwardToUsers_isset = YES;
  }
  if ([decoder containsValueForKey: @"sendPushNotification"])
  {
    __sendPushNotification = [[decoder decodeObjectForKey: @"sendPushNotification"] retain_stub];
    __sendPushNotification_isset = YES;
  }
  if ([decoder containsValueForKey: @"dontSendPushNotification"])
  {
    __dontSendPushNotification = [[decoder decodeObjectForKey: @"dontSendPushNotification"] retain_stub];
    __dontSendPushNotification_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__forwardToSlackChannel_isset)
  {
    [encoder encodeObject: __forwardToSlackChannel forKey: @"forwardToSlackChannel"];
  }
  if (__forwardToSlackUser_isset)
  {
    [encoder encodeObject: __forwardToSlackUser forKey: @"forwardToSlackUser"];
  }
  if (__forwardToGitter_isset)
  {
    [encoder encodeObject: __forwardToGitter forKey: @"forwardToGitter"];
  }
  if (__sendEmail_isset)
  {
    [encoder encodeObject: __sendEmail forKey: @"sendEmail"];
  }
  if (__skipInbox_isset)
  {
    [encoder encodeObject: __skipInbox forKey: @"skipInbox"];
  }
  if (__dontStoreMessage_isset)
  {
    [encoder encodeObject: __dontStoreMessage forKey: @"dontStoreMessage"];
  }
  if (__responseWithMessage_isset)
  {
    [encoder encodeObject: __responseWithMessage forKey: @"responseWithMessage"];
  }
  if (__forwardToUsers_isset)
  {
    [encoder encodeObject: __forwardToUsers forKey: @"forwardToUsers"];
  }
  if (__sendPushNotification_isset)
  {
    [encoder encodeObject: __sendPushNotification forKey: @"sendPushNotification"];
  }
  if (__dontSendPushNotification_isset)
  {
    [encoder encodeObject: __dontSendPushNotification forKey: @"dontSendPushNotification"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __forwardToSlackChannel_isset ? 2654435761 : 0;
  if (__forwardToSlackChannel_isset)
  {
    hash = (hash * 31) ^ [__forwardToSlackChannel hash];
  }
  hash = (hash * 31) ^ __forwardToSlackUser_isset ? 2654435761 : 0;
  if (__forwardToSlackUser_isset)
  {
    hash = (hash * 31) ^ [__forwardToSlackUser hash];
  }
  hash = (hash * 31) ^ __forwardToGitter_isset ? 2654435761 : 0;
  if (__forwardToGitter_isset)
  {
    hash = (hash * 31) ^ [__forwardToGitter hash];
  }
  hash = (hash * 31) ^ __sendEmail_isset ? 2654435761 : 0;
  if (__sendEmail_isset)
  {
    hash = (hash * 31) ^ [__sendEmail hash];
  }
  hash = (hash * 31) ^ __skipInbox_isset ? 2654435761 : 0;
  if (__skipInbox_isset)
  {
    hash = (hash * 31) ^ [__skipInbox hash];
  }
  hash = (hash * 31) ^ __dontStoreMessage_isset ? 2654435761 : 0;
  if (__dontStoreMessage_isset)
  {
    hash = (hash * 31) ^ [__dontStoreMessage hash];
  }
  hash = (hash * 31) ^ __responseWithMessage_isset ? 2654435761 : 0;
  if (__responseWithMessage_isset)
  {
    hash = (hash * 31) ^ [__responseWithMessage hash];
  }
  hash = (hash * 31) ^ __forwardToUsers_isset ? 2654435761 : 0;
  if (__forwardToUsers_isset)
  {
    hash = (hash * 31) ^ [__forwardToUsers hash];
  }
  hash = (hash * 31) ^ __sendPushNotification_isset ? 2654435761 : 0;
  if (__sendPushNotification_isset)
  {
    hash = (hash * 31) ^ [__sendPushNotification hash];
  }
  hash = (hash * 31) ^ __dontSendPushNotification_isset ? 2654435761 : 0;
  if (__dontSendPushNotification_isset)
  {
    hash = (hash * 31) ^ [__dontSendPushNotification hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_AromaAction class]]) {
    return NO;
  }
  AromaReactions_AromaAction *other = (AromaReactions_AromaAction *)anObject;
  if ((__forwardToSlackChannel_isset != other->__forwardToSlackChannel_isset) ||
      (__forwardToSlackChannel_isset && ((__forwardToSlackChannel || other->__forwardToSlackChannel) && ![__forwardToSlackChannel isEqual:other->__forwardToSlackChannel]))) {
    return NO;
  }
  if ((__forwardToSlackUser_isset != other->__forwardToSlackUser_isset) ||
      (__forwardToSlackUser_isset && ((__forwardToSlackUser || other->__forwardToSlackUser) && ![__forwardToSlackUser isEqual:other->__forwardToSlackUser]))) {
    return NO;
  }
  if ((__forwardToGitter_isset != other->__forwardToGitter_isset) ||
      (__forwardToGitter_isset && ((__forwardToGitter || other->__forwardToGitter) && ![__forwardToGitter isEqual:other->__forwardToGitter]))) {
    return NO;
  }
  if ((__sendEmail_isset != other->__sendEmail_isset) ||
      (__sendEmail_isset && ((__sendEmail || other->__sendEmail) && ![__sendEmail isEqual:other->__sendEmail]))) {
    return NO;
  }
  if ((__skipInbox_isset != other->__skipInbox_isset) ||
      (__skipInbox_isset && ((__skipInbox || other->__skipInbox) && ![__skipInbox isEqual:other->__skipInbox]))) {
    return NO;
  }
  if ((__dontStoreMessage_isset != other->__dontStoreMessage_isset) ||
      (__dontStoreMessage_isset && ((__dontStoreMessage || other->__dontStoreMessage) && ![__dontStoreMessage isEqual:other->__dontStoreMessage]))) {
    return NO;
  }
  if ((__responseWithMessage_isset != other->__responseWithMessage_isset) ||
      (__responseWithMessage_isset && ((__responseWithMessage || other->__responseWithMessage) && ![__responseWithMessage isEqual:other->__responseWithMessage]))) {
    return NO;
  }
  if ((__forwardToUsers_isset != other->__forwardToUsers_isset) ||
      (__forwardToUsers_isset && ((__forwardToUsers || other->__forwardToUsers) && ![__forwardToUsers isEqual:other->__forwardToUsers]))) {
    return NO;
  }
  if ((__sendPushNotification_isset != other->__sendPushNotification_isset) ||
      (__sendPushNotification_isset && ((__sendPushNotification || other->__sendPushNotification) && ![__sendPushNotification isEqual:other->__sendPushNotification]))) {
    return NO;
  }
  if ((__dontSendPushNotification_isset != other->__dontSendPushNotification_isset) ||
      (__dontSendPushNotification_isset && ((__dontSendPushNotification || other->__dontSendPushNotification) && ![__dontSendPushNotification isEqual:other->__dontSendPushNotification]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__forwardToSlackChannel release_stub];
  [__forwardToSlackUser release_stub];
  [__forwardToGitter release_stub];
  [__sendEmail release_stub];
  [__skipInbox release_stub];
  [__dontStoreMessage release_stub];
  [__responseWithMessage release_stub];
  [__forwardToUsers release_stub];
  [__sendPushNotification release_stub];
  [__dontSendPushNotification release_stub];
  [super dealloc_stub];
}

- (AromaReactions_ActionForwardToSlackChannel *) forwardToSlackChannel {
  return [[__forwardToSlackChannel retain_stub] autorelease_stub];
}

- (void) setForwardToSlackChannel: (AromaReactions_ActionForwardToSlackChannel *) forwardToSlackChannel {
  [forwardToSlackChannel retain_stub];
  [__forwardToSlackChannel release_stub];
  __forwardToSlackChannel = forwardToSlackChannel;
  __forwardToSlackChannel_isset = YES;
}

- (BOOL) forwardToSlackChannelIsSet {
  return __forwardToSlackChannel_isset;
}

- (void) unsetForwardToSlackChannel {
  [__forwardToSlackChannel release_stub];
  __forwardToSlackChannel = nil;
  __forwardToSlackChannel_isset = NO;
}

- (AromaReactions_ActionForwardToSlackUser *) forwardToSlackUser {
  return [[__forwardToSlackUser retain_stub] autorelease_stub];
}

- (void) setForwardToSlackUser: (AromaReactions_ActionForwardToSlackUser *) forwardToSlackUser {
  [forwardToSlackUser retain_stub];
  [__forwardToSlackUser release_stub];
  __forwardToSlackUser = forwardToSlackUser;
  __forwardToSlackUser_isset = YES;
}

- (BOOL) forwardToSlackUserIsSet {
  return __forwardToSlackUser_isset;
}

- (void) unsetForwardToSlackUser {
  [__forwardToSlackUser release_stub];
  __forwardToSlackUser = nil;
  __forwardToSlackUser_isset = NO;
}

- (AromaReactions_ActionForwardToGitter *) forwardToGitter {
  return [[__forwardToGitter retain_stub] autorelease_stub];
}

- (void) setForwardToGitter: (AromaReactions_ActionForwardToGitter *) forwardToGitter {
  [forwardToGitter retain_stub];
  [__forwardToGitter release_stub];
  __forwardToGitter = forwardToGitter;
  __forwardToGitter_isset = YES;
}

- (BOOL) forwardToGitterIsSet {
  return __forwardToGitter_isset;
}

- (void) unsetForwardToGitter {
  [__forwardToGitter release_stub];
  __forwardToGitter = nil;
  __forwardToGitter_isset = NO;
}

- (AromaReactions_ActionSendEmail *) sendEmail {
  return [[__sendEmail retain_stub] autorelease_stub];
}

- (void) setSendEmail: (AromaReactions_ActionSendEmail *) sendEmail {
  [sendEmail retain_stub];
  [__sendEmail release_stub];
  __sendEmail = sendEmail;
  __sendEmail_isset = YES;
}

- (BOOL) sendEmailIsSet {
  return __sendEmail_isset;
}

- (void) unsetSendEmail {
  [__sendEmail release_stub];
  __sendEmail = nil;
  __sendEmail_isset = NO;
}

- (AromaReactions_ActionSkipInbox *) skipInbox {
  return [[__skipInbox retain_stub] autorelease_stub];
}

- (void) setSkipInbox: (AromaReactions_ActionSkipInbox *) skipInbox {
  [skipInbox retain_stub];
  [__skipInbox release_stub];
  __skipInbox = skipInbox;
  __skipInbox_isset = YES;
}

- (BOOL) skipInboxIsSet {
  return __skipInbox_isset;
}

- (void) unsetSkipInbox {
  [__skipInbox release_stub];
  __skipInbox = nil;
  __skipInbox_isset = NO;
}

- (AromaReactions_ActionDontStoreMessage *) dontStoreMessage {
  return [[__dontStoreMessage retain_stub] autorelease_stub];
}

- (void) setDontStoreMessage: (AromaReactions_ActionDontStoreMessage *) dontStoreMessage {
  [dontStoreMessage retain_stub];
  [__dontStoreMessage release_stub];
  __dontStoreMessage = dontStoreMessage;
  __dontStoreMessage_isset = YES;
}

- (BOOL) dontStoreMessageIsSet {
  return __dontStoreMessage_isset;
}

- (void) unsetDontStoreMessage {
  [__dontStoreMessage release_stub];
  __dontStoreMessage = nil;
  __dontStoreMessage_isset = NO;
}

- (AromaReactions_ActionRespondWithMessage *) responseWithMessage {
  return [[__responseWithMessage retain_stub] autorelease_stub];
}

- (void) setResponseWithMessage: (AromaReactions_ActionRespondWithMessage *) responseWithMessage {
  [responseWithMessage retain_stub];
  [__responseWithMessage release_stub];
  __responseWithMessage = responseWithMessage;
  __responseWithMessage_isset = YES;
}

- (BOOL) responseWithMessageIsSet {
  return __responseWithMessage_isset;
}

- (void) unsetResponseWithMessage {
  [__responseWithMessage release_stub];
  __responseWithMessage = nil;
  __responseWithMessage_isset = NO;
}

- (AromaReactions_ActionForwardToUsers *) forwardToUsers {
  return [[__forwardToUsers retain_stub] autorelease_stub];
}

- (void) setForwardToUsers: (AromaReactions_ActionForwardToUsers *) forwardToUsers {
  [forwardToUsers retain_stub];
  [__forwardToUsers release_stub];
  __forwardToUsers = forwardToUsers;
  __forwardToUsers_isset = YES;
}

- (BOOL) forwardToUsersIsSet {
  return __forwardToUsers_isset;
}

- (void) unsetForwardToUsers {
  [__forwardToUsers release_stub];
  __forwardToUsers = nil;
  __forwardToUsers_isset = NO;
}

- (AromaReactions_ActionSendPushNotification *) sendPushNotification {
  return [[__sendPushNotification retain_stub] autorelease_stub];
}

- (void) setSendPushNotification: (AromaReactions_ActionSendPushNotification *) sendPushNotification {
  [sendPushNotification retain_stub];
  [__sendPushNotification release_stub];
  __sendPushNotification = sendPushNotification;
  __sendPushNotification_isset = YES;
}

- (BOOL) sendPushNotificationIsSet {
  return __sendPushNotification_isset;
}

- (void) unsetSendPushNotification {
  [__sendPushNotification release_stub];
  __sendPushNotification = nil;
  __sendPushNotification_isset = NO;
}

- (AromaReactions_ActionDontSendPushNotification *) dontSendPushNotification {
  return [[__dontSendPushNotification retain_stub] autorelease_stub];
}

- (void) setDontSendPushNotification: (AromaReactions_ActionDontSendPushNotification *) dontSendPushNotification {
  [dontSendPushNotification retain_stub];
  [__dontSendPushNotification release_stub];
  __dontSendPushNotification = dontSendPushNotification;
  __dontSendPushNotification_isset = YES;
}

- (BOOL) dontSendPushNotificationIsSet {
  return __dontSendPushNotification_isset;
}

- (void) unsetDontSendPushNotification {
  [__dontSendPushNotification release_stub];
  __dontSendPushNotification = nil;
  __dontSendPushNotification_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionForwardToSlackChannel *fieldValue = [[AromaReactions_ActionForwardToSlackChannel alloc] init];
          [fieldValue read: inProtocol];
          [self setForwardToSlackChannel: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionForwardToSlackUser *fieldValue = [[AromaReactions_ActionForwardToSlackUser alloc] init];
          [fieldValue read: inProtocol];
          [self setForwardToSlackUser: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionForwardToGitter *fieldValue = [[AromaReactions_ActionForwardToGitter alloc] init];
          [fieldValue read: inProtocol];
          [self setForwardToGitter: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionSendEmail *fieldValue = [[AromaReactions_ActionSendEmail alloc] init];
          [fieldValue read: inProtocol];
          [self setSendEmail: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionSkipInbox *fieldValue = [[AromaReactions_ActionSkipInbox alloc] init];
          [fieldValue read: inProtocol];
          [self setSkipInbox: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionDontStoreMessage *fieldValue = [[AromaReactions_ActionDontStoreMessage alloc] init];
          [fieldValue read: inProtocol];
          [self setDontStoreMessage: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionRespondWithMessage *fieldValue = [[AromaReactions_ActionRespondWithMessage alloc] init];
          [fieldValue read: inProtocol];
          [self setResponseWithMessage: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionForwardToUsers *fieldValue = [[AromaReactions_ActionForwardToUsers alloc] init];
          [fieldValue read: inProtocol];
          [self setForwardToUsers: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionSendPushNotification *fieldValue = [[AromaReactions_ActionSendPushNotification alloc] init];
          [fieldValue read: inProtocol];
          [self setSendPushNotification: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_STRUCT) {
          AromaReactions_ActionDontSendPushNotification *fieldValue = [[AromaReactions_ActionDontSendPushNotification alloc] init];
          [fieldValue read: inProtocol];
          [self setDontSendPushNotification: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AromaAction"];
  if (__forwardToSlackChannel_isset) {
    if (__forwardToSlackChannel != nil) {
      [outProtocol writeFieldBeginWithName: @"forwardToSlackChannel" type: TType_STRUCT fieldID: 1];
      [__forwardToSlackChannel write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardToSlackUser_isset) {
    if (__forwardToSlackUser != nil) {
      [outProtocol writeFieldBeginWithName: @"forwardToSlackUser" type: TType_STRUCT fieldID: 2];
      [__forwardToSlackUser write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardToGitter_isset) {
    if (__forwardToGitter != nil) {
      [outProtocol writeFieldBeginWithName: @"forwardToGitter" type: TType_STRUCT fieldID: 8];
      [__forwardToGitter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sendEmail_isset) {
    if (__sendEmail != nil) {
      [outProtocol writeFieldBeginWithName: @"sendEmail" type: TType_STRUCT fieldID: 3];
      [__sendEmail write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__skipInbox_isset) {
    if (__skipInbox != nil) {
      [outProtocol writeFieldBeginWithName: @"skipInbox" type: TType_STRUCT fieldID: 4];
      [__skipInbox write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__dontStoreMessage_isset) {
    if (__dontStoreMessage != nil) {
      [outProtocol writeFieldBeginWithName: @"dontStoreMessage" type: TType_STRUCT fieldID: 5];
      [__dontStoreMessage write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__responseWithMessage_isset) {
    if (__responseWithMessage != nil) {
      [outProtocol writeFieldBeginWithName: @"responseWithMessage" type: TType_STRUCT fieldID: 6];
      [__responseWithMessage write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__forwardToUsers_isset) {
    if (__forwardToUsers != nil) {
      [outProtocol writeFieldBeginWithName: @"forwardToUsers" type: TType_STRUCT fieldID: 7];
      [__forwardToUsers write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sendPushNotification_isset) {
    if (__sendPushNotification != nil) {
      [outProtocol writeFieldBeginWithName: @"sendPushNotification" type: TType_STRUCT fieldID: 9];
      [__sendPushNotification write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__dontSendPushNotification_isset) {
    if (__dontSendPushNotification != nil) {
      [outProtocol writeFieldBeginWithName: @"dontSendPushNotification" type: TType_STRUCT fieldID: 10];
      [__dontSendPushNotification write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_AromaAction("];
  [ms appendString: @"forwardToSlackChannel:"];
  [ms appendFormat: @"%@", __forwardToSlackChannel];
  [ms appendString: @",forwardToSlackUser:"];
  [ms appendFormat: @"%@", __forwardToSlackUser];
  [ms appendString: @",forwardToGitter:"];
  [ms appendFormat: @"%@", __forwardToGitter];
  [ms appendString: @",sendEmail:"];
  [ms appendFormat: @"%@", __sendEmail];
  [ms appendString: @",skipInbox:"];
  [ms appendFormat: @"%@", __skipInbox];
  [ms appendString: @",dontStoreMessage:"];
  [ms appendFormat: @"%@", __dontStoreMessage];
  [ms appendString: @",responseWithMessage:"];
  [ms appendFormat: @"%@", __responseWithMessage];
  [ms appendString: @",forwardToUsers:"];
  [ms appendFormat: @"%@", __forwardToUsers];
  [ms appendString: @",sendPushNotification:"];
  [ms appendFormat: @"%@", __sendPushNotification];
  [ms appendString: @",dontSendPushNotification:"];
  [ms appendFormat: @"%@", __dontSendPushNotification];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation AromaReactions_Reaction

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.matchers = [[[NSMutableArray alloc] initWithCapacity:0] autorelease_stub];

  self.actions = [[[NSMutableArray alloc] initWithCapacity:0] autorelease_stub];

#endif
  return self;
}

- (id) initWithMatchers: (NSMutableArray *) matchers actions: (NSMutableArray *) actions name: (NSString *) name
{
  self = [super init];
  __matchers = [matchers retain_stub];
  __matchers_isset = YES;
  __actions = [actions retain_stub];
  __actions_isset = YES;
  __name = [name retain_stub];
  __name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"matchers"])
  {
    __matchers = [[decoder decodeObjectForKey: @"matchers"] retain_stub];
    __matchers_isset = YES;
  }
  if ([decoder containsValueForKey: @"actions"])
  {
    __actions = [[decoder decodeObjectForKey: @"actions"] retain_stub];
    __actions_isset = YES;
  }
  if ([decoder containsValueForKey: @"name"])
  {
    __name = [[decoder decodeObjectForKey: @"name"] retain_stub];
    __name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__matchers_isset)
  {
    [encoder encodeObject: __matchers forKey: @"matchers"];
  }
  if (__actions_isset)
  {
    [encoder encodeObject: __actions forKey: @"actions"];
  }
  if (__name_isset)
  {
    [encoder encodeObject: __name forKey: @"name"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __matchers_isset ? 2654435761 : 0;
  if (__matchers_isset)
  {
    hash = (hash * 31) ^ [__matchers hash];
  }
  hash = (hash * 31) ^ __actions_isset ? 2654435761 : 0;
  if (__actions_isset)
  {
    hash = (hash * 31) ^ [__actions hash];
  }
  hash = (hash * 31) ^ __name_isset ? 2654435761 : 0;
  if (__name_isset)
  {
    hash = (hash * 31) ^ [__name hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AromaReactions_Reaction class]]) {
    return NO;
  }
  AromaReactions_Reaction *other = (AromaReactions_Reaction *)anObject;
  if ((__matchers_isset != other->__matchers_isset) ||
      (__matchers_isset && ((__matchers || other->__matchers) && ![__matchers isEqual:other->__matchers]))) {
    return NO;
  }
  if ((__actions_isset != other->__actions_isset) ||
      (__actions_isset && ((__actions || other->__actions) && ![__actions isEqual:other->__actions]))) {
    return NO;
  }
  if ((__name_isset != other->__name_isset) ||
      (__name_isset && ((__name || other->__name) && ![__name isEqual:other->__name]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__matchers release_stub];
  [__actions release_stub];
  [__name release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) matchers {
  return [[__matchers retain_stub] autorelease_stub];
}

- (void) setMatchers: (NSMutableArray *) matchers {
  [matchers retain_stub];
  [__matchers release_stub];
  __matchers = matchers;
  __matchers_isset = YES;
}

- (BOOL) matchersIsSet {
  return __matchers_isset;
}

- (void) unsetMatchers {
  [__matchers release_stub];
  __matchers = nil;
  __matchers_isset = NO;
}

- (NSMutableArray *) actions {
  return [[__actions retain_stub] autorelease_stub];
}

- (void) setActions: (NSMutableArray *) actions {
  [actions retain_stub];
  [__actions release_stub];
  __actions = actions;
  __actions_isset = YES;
}

- (BOOL) actionsIsSet {
  return __actions_isset;
}

- (void) unsetActions {
  [__actions release_stub];
  __actions = nil;
  __actions_isset = NO;
}

- (NSString *) name {
  return [[__name retain_stub] autorelease_stub];
}

- (void) setName: (NSString *) name {
  [name retain_stub];
  [__name release_stub];
  __name = name;
  __name_isset = YES;
}

- (BOOL) nameIsSet {
  return __name_isset;
}

- (void) unsetName {
  [__name release_stub];
  __name = nil;
  __name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_LIST) {
          int _size10;
          [inProtocol readListBeginReturningElementType: NULL size: &_size10];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size10];
          int _i11;
          for (_i11 = 0; _i11 < _size10; ++_i11)
          {
            AromaReactions_AromaMatcher *_elem12 = [[AromaReactions_AromaMatcher alloc] init];
            [_elem12 read: inProtocol];
            [fieldValue addObject: _elem12];
            [_elem12 release_stub];
          }
          [inProtocol readListEnd];
          [self setMatchers: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size13;
          [inProtocol readListBeginReturningElementType: NULL size: &_size13];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size13];
          int _i14;
          for (_i14 = 0; _i14 < _size13; ++_i14)
          {
            AromaReactions_AromaAction *_elem15 = [[AromaReactions_AromaAction alloc] init];
            [_elem15 read: inProtocol];
            [fieldValue addObject: _elem15];
            [_elem15 release_stub];
          }
          [inProtocol readListEnd];
          [self setActions: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Reaction"];
  if (__matchers_isset) {
    if (__matchers != nil) {
      [outProtocol writeFieldBeginWithName: @"matchers" type: TType_LIST fieldID: 1];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__matchers count]];
        int idx17;
        for (idx17 = 0; idx17 < [__matchers count]; idx17++)
        {
          [[__matchers objectAtIndex: idx17] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__actions_isset) {
    if (__actions != nil) {
      [outProtocol writeFieldBeginWithName: @"actions" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__actions count]];
        int idx19;
        for (idx19 = 0; idx19 < [__actions count]; idx19++)
        {
          [[__actions objectAtIndex: idx19] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__name_isset) {
    if (__name != nil) {
      [outProtocol writeFieldBeginWithName: @"name" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AromaReactions_Reaction("];
  [ms appendString: @"matchers:"];
  [ms appendFormat: @"%@", __matchers];
  [ms appendString: @",actions:"];
  [ms appendFormat: @"%@", __actions];
  [ms appendString: @",name:"];
  [ms appendFormat: @"\"%@\"", __name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation AromaReactions_ReactionsConstants
+ (void) initialize {
}
@end

